{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///ObservableData.js","webpack:///webpack/bootstrap 8c23057a113b6700add4","webpack:///./node_modules/common-micro-libs/src/jsutils/dataStore.js","webpack:///./node_modules/common-micro-libs/src/jsutils/EventEmitter.js","webpack:///./node_modules/common-micro-libs/src/jsutils/nextTick.js","webpack:///./src/common.js","webpack:///./node_modules/common-micro-libs/src/jsutils/Compose.js","webpack:///./node_modules/common-micro-libs/src/jsutils/objectExtend.js","webpack:///./src/index.js","webpack:///./src/ObservableArray.js","webpack:///./src/ObservableObject.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","WeakMap","counter","Date","now","Math","random","set","key","entry","writable","undefined","delete","has","window","dataStore","stash","create","default","_interopRequireDefault","obj","getSetup","PRIVATE","listeners","pipes","all","onDestroy","bind","getEventNameList","eventNamesStr","split","_Compose","_Compose2","_dataStore","_dataStore2","arraySlice","Function","Array","slice","isFunction","fn","objectCreate","objectKeys","keys","EventEmitter","extend","on","evName","callback","_this","_getSetup$call","events","reduce","eventList","eventName","callbackIndex","off","push","length","response","forEach","_getSetup$call2","removeCallbackIterator","thisCallback","index","some","once","_this2","eventListeners","eventNameListener","emit","setup","eventPipes","eventAll","args","arguments","isCanceled","callbackHandler","apply","concat","pipe","console","warning","e","pipeTo","prefix","includeInstance","triggeredEvName","unshift","hasListeners","_getSetup$call3","evListener","evEmitter","mixin","target","method","reIsNativeCode","nextTick","processPending","setTimeout","immediates","shift","processing","setImediate","test","toString","Promise","resolved","resolve","then","catch","log","__webpack_exports__","setDependencyTracker","dependeeNotifier","arrayIndexOf","dependeeList","unsetDependencyTracker","arraySplice","stopDependeeNotifications","emitInternalEvent","EV_STOP_DEPENDEE_NOTIFICATION","storeDependeeNotifiers","store","arrayForEach","dependeeCallback","IS_COMPUTED_NOTIFIER","OBJECT_PROTOTYPE","bindCallTo","onInternalEvent","isArray","isPureObject","queueDependeeNotifier","__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter__","__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter___default","__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_nextTick__","__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_nextTick___default","INTERNAL_EVENTS","a","ARRAY_PROTOTYPE","indexOf","splice","dependeeNotifiers","execNotifiers","notifierCb","callNextTick","k","getInstanceState","inst","_objectExtend","_objectExtend2","baseMethods","isDestroyed","init","destroy","getFactory","staticMethods","Factory","_len","_key","newProto","thisObjProto","objKey","isInstanceOf","instanceObj","protoKey","instance","getDestroyCallback","instanceState","stateStore","prop","Compose","objectExtend","mergeIntoObj","mergeObjects","total","deepMerge","_toString","OBJECT_TYPE","_toConsumableArray","arr","arr2","from","observeAll","data","__WEBPACK_IMPORTED_MODULE_2__common__","dataItem","__WEBPACK_IMPORTED_MODULE_1__ObservableObject__","propValue","__WEBPACK_IMPORTED_MODULE_0__ObservableArray__","getInstance","obArray","dependees","isQueued","notify","__WEBPACK_IMPORTED_MODULE_3__common__","cb","__WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_nextTick___default","ev1","cbIndex","makeArrayObservable","isObservable","objectDefineProp","OBSERVABLE_FLAG","noop","newArrProto","__proto__","getOwnPropertyNames","ArrayPrototype","origMethod","doEvents","changeMethods","notifyDependees","arrObj","ObservableArray","__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_dataStore__","__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_dataStore___default","__WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_nextTick__","size","item","_array","updateResponse","arrayInstance","thisPrototype","observableObj","instData","__WEBPACK_IMPORTED_MODULE_3_common_micro_libs_src_jsutils_EventEmitter___default","watched","opt","__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend___default","ObservableObject","defaults","__WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick___default","propName","makePropWatchable","observable","valueGetter","valueSetter","currentValue","emitNotification","propDescriptor","getOwnPropertyDescriptor","propSetup","PropertySetup","oldVal","newVal","objectDefineProperty","__WEBPACK_IMPORTED_MODULE_5__common__","newValue","isComputed","oldValue","deep","makeObservable","Error","createComputedProp","valueGenerator","runValueGenerator","dependencyChangeNotifier","isDestroyDone","observableAssign","_len2","objs","_key2","onEach","watchProp","notifier","objectHasOwnProperty","noopEventListener","watchPropOnce","unwatchProp","notifyPropWatchers","observableMixin","__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose__","__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose___default","__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend__","__WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_dataStore__","__WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_dataStore___default","__WEBPACK_IMPORTED_MODULE_3_common_micro_libs_src_jsutils_EventEmitter__","__WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick__","OBJECT","model","options","watchAll","assign","setProp","_obj","removeDependeeEvListener","queued","noDelay","notifyListeners","createComputed"],"mappings":"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","file":"ObservableData.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ObservableData\"] = factory();\n\telse\n\t\troot[\"ObservableData\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ObservableData\"] = factory();\n\telse\n\t\troot[\"ObservableData\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// POLYFILL FOR WEAKMAP\n//  [pt] changed how \"delete\" is defined so that it can work in IE8\n\n/* jshint ignore:start */\n/**\r\n * @license\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\nif (typeof WeakMap === 'undefined') {\n  (function () {\n    var defineProperty = Object.defineProperty;\n    var counter = Date.now() % 1e9;\n\n    var WeakMap = function WeakMap() {\n      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\n    };\n\n    WeakMap.prototype = {\n      set: function set(key, value) {\n        var entry = key[this.name];\n        if (entry && entry[0] === key) entry[1] = value;else defineProperty(key, this.name, { value: [key, value], writable: true });\n        return this;\n      },\n      get: function get(key) {\n        var entry;\n        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n      },\n      // [pt] Quotes around the delete property needed for IE8\n      \"delete\": function _delete(key) {\n        var entry = key[this.name];\n        if (!entry || entry[0] !== key) return false;\n        entry[0] = entry[1] = undefined;\n        return true;\n      },\n      has: function has(key) {\n        var entry = key[this.name];\n        if (!entry) return false;\n        return entry[0] === key;\n      }\n    };\n\n    window.WeakMap = WeakMap;\n  })();\n}\n/* jshint ignore:end */\n\n/**\r\n * Returns an object that contains an initialized WeakMap (`stash` property)\r\n * where data can be stored.\r\n *\r\n * @namespace dataStore\r\n *\r\n */\nvar dataStore = /** @lends dataStore */{\n  /**\r\n   * Stash data here.\r\n   * @type WeakMap\r\n   */\n  stash: new WeakMap(),\n  /**\r\n   * Create a private data store and return it.\r\n   * @return {WeakMap}\r\n   */\n  create: function create() {\n    return new WeakMap();\n  }\n};\n\nexports.default = dataStore;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Compose = __webpack_require__(4);\n\nvar _Compose2 = _interopRequireDefault(_Compose);\n\nvar _dataStore = __webpack_require__(0);\n\nvar _dataStore2 = _interopRequireDefault(_dataStore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//----------------------------------------------------------------\nvar PRIVATE = _dataStore2.default.create();\nvar arraySlice = Function.call.bind(Array.prototype.slice);\nvar isFunction = function isFunction(fn) {\n    return typeof fn === \"function\";\n};\nvar objectCreate = Object.create;\nvar objectKeys = Object.keys;\n\n/**\r\n * Emits events. Use it to extend other modules and thus add events to them.\r\n *\r\n * @class EventEmitter\r\n * @extends Compose\r\n */\nvar EventEmitter = _Compose2.default.extend( /** @lends EventEmitter.prototype */{\n    /**\r\n     * Add a callback to a given event name\r\n     *\r\n     * @param {String} evName\r\n     *  The event name to be listened to or a list of event sperated by a space.\r\n     *  The EventEmitter instance can be used as the `evName` as well which will\r\n     *  essentially listen to all events.\r\n     *  Note that this special event however, will change the arguments\r\n     *  passed to the callback by pre-pending the Event Name (`String`) and\r\n     *  appending the Component instance.\r\n     *\r\n     * @param {Function} callback\r\n     *  A callback function to listen to the event. The callback function\r\n     *  can cancel any queued event callbacks by returning `true` (boolean).\r\n     *\r\n     * @return {EventEmitter#EventListener}\r\n     *\r\n     * @example\r\n     *\r\n     * events.on(\"some-event\", (...args) => {});\r\n     *\r\n     * // List to all events\r\n     * events.on(events, (evNameTriggered, ...args) => {}\r\n     */\n    on: function on(evName, callback) {\n        var _this = this;\n\n        var _getSetup$call = getSetup.call(this),\n            all = _getSetup$call.all,\n            listeners = _getSetup$call.listeners;\n\n        var events = getEventNameList(evName).reduce(function (eventList, eventName) {\n            var callbackIndex = void 0;\n            var off = void 0;\n\n            // If eventName is `this` then listen to all events\n            if (eventName === _this) {\n                all.push(callback);\n                callbackIndex = all.length - 1;\n                off = function off() {\n                    return all[callbackIndex] = null;\n                };\n            } else {\n                if (!(eventName in listeners)) {\n                    listeners[eventName] = [];\n                }\n\n                listeners[eventName].push(callback);\n                callbackIndex = listeners[eventName].length - 1;\n                off = function off() {\n                    return listeners[eventName][callbackIndex] = null;\n                };\n            }\n\n            eventList[eventName] = objectCreate({ off: off });\n            return eventList;\n        }, {});\n        /**\r\n         * EventEmitter Listener object, returned when one of the listener setter methods\r\n         * (ex. `on()`, `once()`, `pipe`) are used.\r\n         *\r\n         * @typedef {Object} EventEmitter~EventListener\r\n         *\r\n         * @property {Object} listeners\r\n         *  An object with the individual listeners. Each respective event listener\r\n         *  has an `off()` method to turn that listener off.\r\n         *\r\n         * @property {Function} off\r\n         *  Remove callback from event.\r\n         */\n        var response = objectCreate({\n            off: function off() {\n                objectKeys(events).forEach(function (eventName) {\n                    return events[eventName].off();\n                });\n            }\n        });\n\n        response.listeners = events;\n        return response;\n    },\n\n    /**\r\n     * Remove a callback from a given event\r\n     *\r\n     * @param {String} evName\r\n     * @param {Function} callback\r\n     *\r\n     */\n    off: function off(evName, callback) {\n        var _getSetup$call2 = getSetup.call(this),\n            all = _getSetup$call2.all,\n            listeners = _getSetup$call2.listeners;\n\n        var removeCallbackIterator = function removeCallbackIterator(thisCallback, index) {\n            if (thisCallback === callback) {\n                listeners[evName][index] = null;\n                return true;\n            }\n        };\n\n        if (evName === this) {\n            all.some(removeCallbackIterator);\n            return;\n        }\n\n        if (evName in listeners) {\n            listeners[evName].some(removeCallbackIterator);\n        }\n    },\n\n    /**\r\n     * Add a callback to a given event name that is executed only once.\r\n     *\r\n     * @param {String} evName\r\n     *  The event name. This can be a list of event delimited with a space. Each\r\n     *  event listeners will be triggered at most once.\r\n     * @param {Function} callback\r\n     *\r\n     * @return {EventEmitter#EventListener}\r\n     */\n    once: function once(evName, callback) {\n        var _this2 = this;\n\n        var events = getEventNameList(evName).reduce(function (eventListeners, eventName) {\n            var eventNameListener = _this2.on(evName, function () {\n                eventNameListener.off();\n                callback.apply(undefined, arguments);\n            });\n\n            eventListeners[eventName] = eventNameListener;\n            return eventListeners;\n        }, {});\n\n        var response = objectCreate({\n            off: function off() {\n                objectKeys(events).forEach(function (eventName) {\n                    return events[eventName].off();\n                });\n            }\n        });\n\n        response.listeners = events;\n        return response;\n    },\n\n    /**\r\n     * Emit an event and execute any callback listening. Any of the listening\r\n     * events can cancel the calling of queued callbacks by returning `true`\r\n     * (boolean)\r\n     *\r\n     * @param {String} evName\r\n     *  The event name to be triggered. __NOTE__: can not be a `\"*\"` or the EventEmitter\r\n     *  instance since they holds special meaning.\r\n     *\r\n     * @param {...Function} callbackArgs\r\n     */\n    emit: function emit(evName) {\n        if (evName === \"*\" || evName === this) {\n            try {\n                console.warning(\"EventEmitter#emit(): can not emit to events to '*'\");\n            } catch (e) {} // jshint ignore:line\n            return;\n        }\n\n        var setup = getSetup.call(this),\n            eventListeners = setup.listeners,\n            eventPipes = setup.pipes,\n            eventAll = setup.all,\n            args = arraySlice(arguments, 1),\n            isCanceled = false,\n            callbackHandler = function callbackHandler(callback) {\n            if (isFunction(callback)) {\n                var response = callback.apply(callback, args);\n\n                // if a boolean true was returned, don't call any more\n                // listeners.\n                if (response && typeof response === \"boolean\") {\n                    isCanceled = true;\n                    return true;\n                }\n            }\n        };\n\n        if (evName in eventListeners) {\n            // Regular event listeners\n            (eventListeners[evName] || []).some(callbackHandler);\n        }\n\n        // Event listeners for all events\n        if (!isCanceled && (\"*\" in eventListeners || eventAll.length)) {\n            // Special event \"*\": pass event name and instance\n            args = arraySlice(arguments, 0);\n            args.push(this);\n\n            (eventListeners[\"*\"] || []).concat(eventAll).some(callbackHandler);\n\n            // set args back to original\n            args = arraySlice(arguments, 1);\n        }\n\n        eventPipes.forEach(function (pipe) {\n            if (isFunction(pipe)) {\n                pipe(evName, args);\n            }\n        });\n    },\n\n    /**\r\n     * Emit the events from one instance of EventEmitter to another. Useful\r\n     * for when multiple components are used together as part of a larger\r\n     * component and have the need to emit events to a common EventEmitter.\r\n     *\r\n     * @param {EventEmitter} pipeTo\r\n     *  The EventEmitter instance object to where events should be piped.\r\n     *\r\n     * @param {String} [prefix]\r\n     *  If defined, prefix will be added to any event emited. Example:\r\n     *  if defining `foo-` as the prefix, then every event emitted will\r\n     *  prefixed wth this value. So a `click` event on the source will\r\n     *  be piped as `foo-click`.\r\n     *\r\n     * @param {Boolean} [includeInstance=true]\r\n     *  When set to `true` (default), the piped event will include the source\r\n     *  instance as an additional argument to the event that is piped.\r\n     *\r\n     *  @return {EventListener}\r\n     */\n    pipe: function pipe(pipeTo, prefix, includeInstance) {\n        if (!pipeTo || !pipeTo.on) {\n            return objectCreate({ off: function off() {} });\n        }\n        var pipes = getSetup.call(this).pipes,\n            callbackIndex;\n\n        pipes.push(function (triggeredEvName, args) {\n            if (prefix) {\n                args.unshift(prefix + triggeredEvName);\n            } else {\n                args.unshift(triggeredEvName);\n            }\n\n            if (includeInstance || typeof includeInstance === \"undefined\") {\n                args.push(this);\n            }\n\n            pipeTo.emit.apply(pipeTo, args);\n        }.bind(this));\n\n        callbackIndex = pipes.length - 1;\n\n        return objectCreate({\n            off: function off() {\n                pipes[callbackIndex] = null;\n            }\n        });\n    },\n\n    /**\r\n     * Returns a boolean indicating if the current EventEmitter has listener\r\n     * @returns {Boolean}\r\n     */\n    hasListeners: function hasListeners() {\n        var _getSetup$call3 = getSetup.call(this),\n            listeners = _getSetup$call3.listeners,\n            pipes = _getSetup$call3.pipes;\n\n        return objectKeys(listeners).some(function (evName) {\n            return listeners[evName].some(function (evListener) {\n                return !!evListener;\n            });\n        }) || pipes.some(function (evEmitter) {\n            return !!evEmitter;\n        });\n    }\n});\n\n/**\r\n * Returns the instance setup object. Creates it if it does not have one.\r\n * @private\r\n * @this EventEmitter\r\n */\nfunction getSetup() {\n    if (!PRIVATE.has(this)) {\n        /*\r\n            listeners: {\r\n                'evName': [ Callbacks ]\r\n            },\r\n            pipes: [ Callbacks ]\r\n            all: [ Callbacks ]\r\n        */\n        PRIVATE.set(this, {\n            listeners: {},\n            pipes: [],\n            all: []\n        });\n\n        // When this object is destroyed, remove all data\n        if (this.onDestroy) {\n            this.onDestroy(function () {\n                if (PRIVATE.has(this)) {\n                    PRIVATE['delete'](this); // using ['delete'] because of IE\n                }\n            }.bind(this));\n        }\n    }\n    return PRIVATE.get(this);\n}\n\nfunction getEventNameList(eventNamesStr) {\n    if (\"string\" === typeof eventNamesStr) {\n        return eventNamesStr.split(/\\s+/);\n    }\n    return [eventNamesStr];\n}\n\n/**\r\n * Adds event emitter functionality to an object\r\n *\r\n * @param {Object} target\r\n */\nEventEmitter.mixin = function (target) {\n    if (target) {\n        [\"on\", \"off\", \"emit\", \"once\", \"pipe\"].forEach(function (method) {\n            Object.defineProperty(target, method, {\n                configurable: true,\n                value: EventEmitter.prototype[method].bind(target)\n            });\n        });\n    }\n};\n\nexports.default = EventEmitter;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar reIsNativeCode = /native code/i;\n\n/**\r\n * Executes a function at the end of the current event Loop - during micro-task processing\r\n *\r\n * @param {Function} callback\r\n */\nvar nextTick = function () {\n    if (typeof setImediate !== \"undefined\" && reIsNativeCode.test(setImediate.toString())) {\n        return setImediate;\n    }\n\n    // Native Promsie? Use it.\n    if (typeof Promise === 'function' && reIsNativeCode.test(Promise.toString())) {\n        var resolved = Promise.resolve();\n        return function _nextTick(fn) {\n            resolved.then(fn).catch(function (e) {\n                return console.log(e);\n            });\n        };\n    }\n\n    // fallback to setTimeout\n    // From: https://bugzilla.mozilla.org/show_bug.cgi?id=686201#c68\n    var immediates = [];\n    var processing = false;\n\n    function processPending() {\n        setTimeout(function () {\n            immediates.shift()();\n            if (immediates.length) {\n                processPending();\n            } else {\n                processing = false;\n            }\n        }, 0);\n    }\n\n    return function _nextTick(fn) {\n        immediates.push(fn);\n        if (!processing) {\n            processing = true;\n            processPending();\n        }\n    };\n}();\n\nexports.default = nextTick;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export INTERNAL_EVENTS */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return EV_STOP_DEPENDEE_NOTIFICATION; });\n/* unused harmony export ARRAY_PROTOTYPE */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return IS_COMPUTED_NOTIFIER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return OBJECT_PROTOTYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return bindCallTo; });\n/* unused harmony export dependeeList */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return onInternalEvent; });\n/* unused harmony export emitInternalEvent */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return arrayIndexOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return arraySplice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return arrayForEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return isPureObject; });\n/* harmony export (immutable) */ __webpack_exports__[\"l\"] = setDependencyTracker;\n/* harmony export (immutable) */ __webpack_exports__[\"o\"] = unsetDependencyTracker;\n/* harmony export (immutable) */ __webpack_exports__[\"m\"] = stopDependeeNotifications;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return queueDependeeNotifier; });\n/* harmony export (immutable) */ __webpack_exports__[\"n\"] = storeDependeeNotifiers;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_nextTick__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_nextTick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_nextTick__);\n\n\n\n//=======================================================================\n\nvar INTERNAL_EVENTS = __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter___default.a.create();\nvar EV_STOP_DEPENDEE_NOTIFICATION = \"1\";\nvar ARRAY_PROTOTYPE = Array.prototype;\nvar IS_COMPUTED_NOTIFIER = \"__od_cn__\";\nvar OBJECT_PROTOTYPE = Object.prototype;\n\nvar bindCallTo = Function.call.bind.bind(Function.call);\nvar dependeeList = [];\nvar onInternalEvent = INTERNAL_EVENTS.on.bind(INTERNAL_EVENTS);\nvar emitInternalEvent = INTERNAL_EVENTS.emit.bind(INTERNAL_EVENTS);\nvar isArray = Array.isArray;\nvar arrayIndexOf = bindCallTo(ARRAY_PROTOTYPE.indexOf);\nvar arraySplice = bindCallTo(ARRAY_PROTOTYPE.splice);\nvar arrayForEach = bindCallTo(ARRAY_PROTOTYPE.forEach);\nvar isPureObject = function isPureObject(o) {\n    return o && OBJECT_PROTOTYPE.toString.call(o) === \"[object Object]\";\n};\n\n/**\r\n * Allows for adding a Dependee notifier to the global list of dependency trackers.\r\n *\r\n * @param {Function} dependeeNotifier\r\n */\nfunction setDependencyTracker(dependeeNotifier) {\n    if (dependeeNotifier && arrayIndexOf(dependeeList, dependeeNotifier) === -1) {\n        dependeeList.push(dependeeNotifier);\n    }\n}\n\n/**\r\n * Removes a Dependee notifier from the global list of dependency trackers.\r\n *\r\n * @param {Function} dependeeNotifier\r\n */\nfunction unsetDependencyTracker(dependeeNotifier) {\n    if (!dependeeNotifier) {\n        return;\n    }\n    var index = arrayIndexOf(dependeeList, dependeeNotifier);\n    if (index !== -1) {\n        arraySplice(dependeeList, index, 1);\n    }\n}\n\n/**\r\n * Removes a Dependee notifier from any stored ObservableProperty list of dependees, thus\r\n * stopping all notifications to that depenedee.\r\n *\r\n * @param {Function} dependeeNotifier\r\n */\nfunction stopDependeeNotifications(dependeeNotifier) {\n    if (dependeeNotifier) {\n        emitInternalEvent(EV_STOP_DEPENDEE_NOTIFICATION, dependeeNotifier);\n    }\n}\n\nvar queueDependeeNotifier = function () {\n    var dependeeNotifiers = [];\n    var execNotifiers = function execNotifiers() {\n        return arrayForEach(arraySplice(dependeeNotifiers, 0), function (notifierCb) {\n            return notifierCb();\n        });\n    };\n\n    return function (notifierCb) {\n        if (!notifierCb || arrayIndexOf(dependeeNotifiers, notifierCb) !== -1) {\n            return;\n        }\n\n        // Computed property notifiers are lightweight, so execute\n        // these now and don't queue them.\n        if (notifierCb[IS_COMPUTED_NOTIFIER]) {\n            notifierCb();\n            return;\n        }\n\n        var callNextTick = !dependeeNotifiers.length;\n        dependeeNotifiers.push(notifierCb);\n\n        if (callNextTick) {\n            __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_nextTick___default()(execNotifiers);\n        }\n    };\n}();\n\nfunction storeDependeeNotifiers(store) {\n    if (store && dependeeList.length) {\n        arrayForEach(dependeeList, function (dependeeCallback) {\n            if (arrayIndexOf(store, dependeeCallback) === -1) {\n                store.push(dependeeCallback);\n            }\n        });\n    }\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _objectExtend = __webpack_require__(5);\n\nvar _objectExtend2 = _interopRequireDefault(_objectExtend);\n\nvar _dataStore = __webpack_require__(0);\n\nvar _dataStore2 = _interopRequireDefault(_dataStore);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//=========================================================\nvar PRIVATE = _dataStore2.default.create();\n\n// Aliases\nvar objectCreate = Object.create;\n\n// return all KEYs of an object, even those that are not iterable\nfunction objectKeys(prototype) {\n    var k = void 0,\n        keys = [];\n    for (k in prototype) {\n        keys.push(k);\n    }\n    return keys;\n}\n\n// Base instance methods for Compose'd object\nvar baseMethods = /** @lends Compose.prototype */{\n\n    /**\r\n     * Property indicating whether instance has been destroyed\r\n     */\n    isDestroyed: false,\n\n    /**\r\n     * instance initializing code\r\n     */\n    init: function init() {},\n\n    /**\r\n     * Destroys the instance, by removing its private data.\r\n     */\n    destroy: function destroy() {\n        if (PRIVATE.has(this)) {\n            PRIVATE.get(this).forEach(function (callback, i) {\n                if (\"function\" === typeof callback) {\n                    callback();\n                }\n            });\n\n            PRIVATE.delete(this);\n        }\n\n        if (\"boolean\" === typeof this.isDestroyed) {\n            this.isDestroyed = true;\n        }\n    },\n\n    /**\r\n     * Adds a callback to the queue to be called when this object's `.destroy()`\r\n     * is called.\r\n     *\r\n     * @param {Function} callback\r\n     */\n    onDestroy: function onDestroy(callback) {\n        getInstanceState(this).push(callback);\n    },\n\n    /**\r\n     * Returns the factory for this instance.\r\n     *\r\n     * @return {Compose}\r\n     */\n    getFactory: function getFactory() {} // set by .extend()\n};\n\nvar staticMethods = /** @lends Compose */{\n\n    /**\r\n     * Creates an new factory based on the prototye of the current Factory\r\n     * and any other Factory given on input.\r\n     *\r\n     * @return {Compose}\r\n     */\n    extend: function extend() {\n        var Factory = function Factory() {};\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        Factory.prototype = args.reduce(function (newProto, obj) {\n            if (obj) {\n                var thisObjProto = obj.prototype || obj;\n                objectKeys(thisObjProto).forEach(function (objKey) {\n                    newProto[objKey] = thisObjProto[objKey];\n                });\n            }\n            return newProto;\n        }, objectCreate(this.prototype));\n\n        // Add a method to the Factory prototype that allows retrieval of\n        // factory static properties.\n        Factory.prototype.getFactory = function () {\n            return Factory;\n        };\n\n        // Extend new factory with statics from this factory\n        return (0, _objectExtend2.default)(true, Factory, this);\n    },\n\n    /**\r\n     * Checks if the Object given on input looks like an instance of this Factory.\r\n     *\r\n     * @return {Boolean}\r\n     */\n    isInstanceOf: function isInstanceOf(instanceObj) {\n\n        if (!instanceObj) {\n            return false;\n        }\n\n        var neededKeys = objectKeys(this.prototype);\n\n        // If any prototype key is not in the object prototype, then return false\n        return !neededKeys.some(function (protoKey) {\n            return typeof instanceObj[protoKey] === \"undefined\";\n        });\n    },\n\n    /**\r\n     * Creates an instance object based on this factory.\r\n     *\r\n     * @return {Object}\r\n     */\n    create: function create() {\n        var instance = objectCreate(this.prototype);\n        if (instance.init) {\n            instance.init.apply(instance, arguments);\n        }\n        return instance;\n    },\n\n    /**\r\n     * Returns a standard callback that can be used to remove cleanup instance state\r\n     * from specific Store (WeakMap). Returned function will destroy known Instances\r\n     * that have destroy methods.\r\n     *\r\n     * @param {Object} instanceState\r\n     * @param {WeakMap} [stateStore]\r\n     *\r\n     * @return {Function}\r\n     *\r\n     * @example\r\n     *\r\n     * const MY_PRIVATE = new WeakMap();\r\n     * cont NewWdg = Componse.extend({\r\n     *      init() {\r\n     *          const state = {};\r\n     *          MY_PRIVATE.set(this, state);\r\n     *          ...\r\n     *\r\n     *          this.onDestroy(Compose.getDestroyCallback(state, MY_PRIVATE));\r\n     *      }\r\n     * });\r\n     */\n    getDestroyCallback: function getDestroyCallback(instanceState, stateStore) {\n        return function () {\n            if (instanceState) {\n                // Destroy all Compose object\n                Object.keys(instanceState).forEach(function (prop) {\n                    if (instanceState[prop]) {\n                        [\"destroy\", // Compose\n                        \"remove\", // DOM Events Listeners\n                        \"off\" // EventEmitter Listeners\n                        ].some(function (method) {\n                            if (instanceState[prop][method]) {\n                                instanceState[prop][method]();\n                                return true;\n                            }\n                        });\n\n                        instanceState[prop] = undefined;\n                    }\n                });\n            }\n\n            if (stateStore && stateStore.has && stateStore.has(instanceState)) {\n                stateStore['delete'](instanceState);\n            }\n        };\n    }\n};\n\nfunction getInstanceState(inst) {\n    if (!PRIVATE.has(inst)) {\n        PRIVATE.set(inst, []);\n    }\n\n    return PRIVATE.get(inst);\n}\n\n/**\r\n * Composes new factory methods from a list of given Objects/Classes.\r\n *\r\n * @class Compose\r\n *\r\n * @example\r\n *\r\n * var Widget = Compose.create(Model, Events);\r\n *\r\n * myWidget = Widget.create();\r\n *\r\n */\nvar Compose = function Compose() {};\nCompose.prototype = objectCreate(baseMethods);\n(0, _objectExtend2.default)(Compose, staticMethods);\n\nexports.default = Compose;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = objectExtend;\nvar OBJECT_TYPE = \"[object Object]\";\nvar _toString = Function.call.bind(Object.prototype.toString);\n\n//============================================================\n\n/**\r\n * Extends an object with the properties of another.\r\n *\r\n * @param {Object|Boolean} mergeIntoObj\r\n *  The object that will have the properties of every other object provided\r\n *  on input merged into. This can also be a `Boolean`, in which case,\r\n *  a deep merge of objects will be done - argument number 2 will\r\n *  become the `mergeIntoObj`.\r\n * @param {...Object} mergeObjects\r\n *\r\n * @return {Object}\r\n */\nfunction objectExtend(mergeIntoObj) {\n    var response = mergeIntoObj || {};\n\n    for (var _len = arguments.length, mergeObjects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        mergeObjects[_key - 1] = arguments[_key];\n    }\n\n    var total = mergeObjects.length;\n    var deepMerge = false;\n    var i = void 0;\n    var key = void 0;\n\n    if (typeof mergeIntoObj === \"boolean\") {\n        deepMerge = mergeIntoObj;\n        response = mergeObjects.shift() || {};\n        total = mergeObjects.length;\n    }\n\n    for (i = 0; i < total; i++) {\n        if (!mergeObjects[i]) {\n            continue;\n        }\n\n        for (key in mergeObjects[i]) {\n            if (mergeObjects[i].hasOwnProperty(key)) {\n                if (deepMerge && _toString(response[key]) === OBJECT_TYPE && _toString(mergeObjects[i][key]) === OBJECT_TYPE) {\n                    response[key] = objectExtend(true, response[key], mergeObjects[i][key]);\n                } else {\n                    response[key] = mergeObjects[i][key];\n                }\n            }\n        }\n    }\n    return response;\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"observeAll\"] = observeAll;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ObservableArray__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ObservableObject__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common__ = __webpack_require__(3);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ObservableArray\", function() { return __WEBPACK_IMPORTED_MODULE_0__ObservableArray__[\"a\"]; });\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"ObservableObject\", function() { return __WEBPACK_IMPORTED_MODULE_1__ObservableObject__[\"a\"]; });\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n//==================================================================\n\n/**\r\n * Observes all data - object and arrays - given on input.\r\n *\r\n * @param {...Object|...Array} data\r\n */\nfunction observeAll() {\n    for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {\n        data[_key] = arguments[_key];\n    }\n\n    Object(__WEBPACK_IMPORTED_MODULE_2__common__[\"d\" /* arrayForEach */])(data, function (dataItem) {\n        if (Object(__WEBPACK_IMPORTED_MODULE_2__common__[\"i\" /* isPureObject */])(dataItem)) {\n            Object(__WEBPACK_IMPORTED_MODULE_1__ObservableObject__[\"b\" /* makeObservable */])(dataItem, null, true, function (propValue) {\n                if (propValue && Object(__WEBPACK_IMPORTED_MODULE_2__common__[\"h\" /* isArray */])(propValue)) {\n                    observeAll(propValue);\n                }\n            });\n        } else if (Object(__WEBPACK_IMPORTED_MODULE_2__common__[\"h\" /* isArray */])(dataItem)) {\n            Object(__WEBPACK_IMPORTED_MODULE_0__ObservableArray__[\"b\" /* mixin */])(dataItem);\n            observeAll.apply(undefined, _toConsumableArray(dataItem));\n        }\n    });\n}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = mixin;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_dataStore__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_dataStore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_dataStore__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_nextTick__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_nextTick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_nextTick__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common__ = __webpack_require__(3);\n/* unused harmony reexport setDependencyTracker */\n/* unused harmony reexport unsetDependencyTracker */\n/* unused harmony reexport stopDependeeNotifications */\n\n\n\n\n\n\n//==============================================================\nvar PRIVATE = __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_dataStore___default.a.create();\nvar OBSERVABLE_FLAG = \"___observable_array___\";\nvar ArrayPrototype = Array.prototype;\nvar objectDefineProp = Object.defineProperty;\nvar noop = function noop() {};\nvar isObservable = function isObservable(arr) {\n    return arr[OBSERVABLE_FLAG] === noop;\n};\nvar changeMethods = ['pop', 'push', 'shift', 'splice', 'unshift', 'sort', 'reverse'];\n\n/**\r\n * An Array like object with the added ability to listen to events.\r\n * It supports all methods available to a normal array, like `forEach`,\r\n * `some` and `reduce`\r\n *\r\n * @class ObservableArray\r\n *\r\n * @extends EventEmitter\r\n * @extends Array\r\n *\r\n * @fires ObservableArray#change\r\n */\nvar ObservableArray = __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter___default.a.extend( /** @lends ObservableArray.prototype */{\n\n    /**\r\n     * The length of the array. Unlike the `length` property, this one is able\r\n     * to notify dependees if any are set to be track dependencies.\r\n     *\r\n     * @name len\r\n     * @type {Number}\r\n     */\n\n    // For backwards compatible with initial version\n    // use `len` property instead\n    size: function size() {\n        Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"n\" /* storeDependeeNotifiers */])(getInstance(this).dependees);\n        return this.length;\n    },\n\n    /**\r\n     * Returns a member of the collection given an index (zero based),\r\n     * or updates the item at a given index with a new value.\r\n     *\r\n     * @param {Number} index\r\n     * @param {*} [newValue]\r\n     */\n    item: function item(index) {\n        var args = ArrayPrototype.slice.call(arguments, 0);\n        var _array = this;\n\n        Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"n\" /* storeDependeeNotifiers */])(getInstance(this).dependees);\n\n        // GET mode..\n        if (args.length === 1) {\n            return _array[index];\n        }\n\n        // Update mode... Emits event\n        var updateResponse = _array[index] = args[1];\n        notifyDependees(_array);\n\n        return updateResponse;\n    }\n});\n\nfunction getInstance(obArray) {\n    if (!PRIVATE.has(obArray)) {\n        var dependees = [];\n        var isQueued = false;\n        var inst = {\n            dependees: dependees,\n\n            notify: function notify() {\n                // Queue up calling all dependee notifiers\n                Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"d\" /* arrayForEach */])(dependees, function (cb) {\n                    return Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"k\" /* queueDependeeNotifier */])(cb);\n                });\n\n                if (isQueued) {\n                    return;\n                }\n\n                /**\r\n                 * ObservableArray was changed. Event will provide the value returned\r\n                 * by the Array method that made the change.\r\n                 *\r\n                 * @event ObservableArray#change\r\n                 * @type {*}\r\n                 */\n                __WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_nextTick___default()(function () {\n                    __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_EventEmitter___default.a.prototype.emit.call(obArray, \"change\");\n                    isQueued = false;\n                });\n            }\n        };\n\n        PRIVATE.set(obArray, inst);\n\n        var ev1 = Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"j\" /* onInternalEvent */])(__WEBPACK_IMPORTED_MODULE_3__common__[\"a\" /* EV_STOP_DEPENDEE_NOTIFICATION */], function (cb) {\n            var cbIndex = Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"e\" /* arrayIndexOf */])(dependees, cb);\n            if (cbIndex !== -1) {\n                Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"f\" /* arraySplice */])(dependees, cbIndex, 1);\n            }\n        });\n\n        if (obArray.onDestroy) {\n            obArray.onDestroy(function () {\n                dependees.splice(0);\n                ev1.off();\n                PRIVATE.delete(obArray);\n            });\n        }\n    }\n    return PRIVATE.get(obArray);\n}\n\n/**\r\n * Converts an array instance methods to a wrapped version that can detect changes\r\n * and also track dependee notifiers when data is accessed from the array\r\n *\r\n * @param {Array} arr\r\n *\r\n * @return {Array}\r\n */\nfunction makeArrayObservable(arr) {\n    // If it looks like this array is already an being observered, then exit.\n    if (isObservable(arr)) {\n        return;\n    }\n\n    objectDefineProp(arr, OBSERVABLE_FLAG, { get: function get() {\n            return noop;\n        } });\n\n    // Create new Array instance prototype\n    var newArrProto = Object.create(arr.__proto__); // eslint-disable-line\n\n    // Add all methods of Array.prototype to the collection\n    Object.getOwnPropertyNames(ArrayPrototype).forEach(function (method) {\n        if (method === \"constructor\" || typeof ArrayPrototype[method] !== \"function\") {\n            return;\n        }\n\n        var origMethod = newArrProto[method].bind(arr);\n        var doEvents = changeMethods.indexOf(method) !== -1;\n\n        objectDefineProp(newArrProto, method, {\n            value: function observable() {\n                Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"n\" /* storeDependeeNotifiers */])(getInstance(this).dependees);\n\n                var response = origMethod.apply(undefined, arguments);\n\n                // If the response is an array and its not this instance, then\n                // ensure it is an instance of this ObservableArray\n                if (Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"h\" /* isArray */])(response) && response !== this && this.getFactory) {\n                    response = this.getFactory().create(response);\n                }\n\n                // If Array method can manipulate the array, then emit event\n                if (doEvents) {\n                    notifyDependees(this);\n                }\n\n                return response;\n            },\n            writable: true,\n            configurable: true\n        });\n    });\n\n    // Add `len` property, which is shorthand for `length` but with added\n    // ability to observe for array changes when called and trigger notifiers\n    // when changed.\n    objectDefineProp(newArrProto, \"len\", {\n        get: function get() {\n            Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"n\" /* storeDependeeNotifiers */])(getInstance(this).dependees);\n            return this.length;\n        },\n        set: function set(n) {\n            var response = this.length = n;\n            notifyDependees(this);\n            return response;\n        },\n\n\n        configurable: true\n    });\n\n    arr.__proto__ = newArrProto; // eslint-disable-line\n\n    return arr;\n}\n\nfunction notifyDependees(arrObj) {\n    getInstance(arrObj).notify();\n}\n\n/**\r\n * Make an array instance observable in place\r\n *\r\n * @param {Array} arr\r\n *\r\n * @return {Array}\r\n */\nfunction mixin(arr) {\n    if (!Object(__WEBPACK_IMPORTED_MODULE_3__common__[\"h\" /* isArray */])(arr)) {\n        arr = [];\n    }\n\n    return ObservableArray.create(arr);\n}\n\n// Define the \"create\" factory method that will then redefine each\n// our proxyied methods of Array prototype into the array instance\nobjectDefineProp(ObservableArray, \"create\", {\n    value: function value(arrayInstance) {\n        var instance = arrayInstance || [];\n        var thisPrototype = this.prototype;\n\n        if (isObservable(instance)) {\n            return instance;\n        }\n\n        makeArrayObservable(instance);\n\n        // Copy all methods in this prototype to the Array instance\n        for (var prop in thisPrototype) {\n            /* eslint-disable */\n            objectDefineProp(instance, prop, {\n                value: thisPrototype[prop],\n                writable: true,\n                configurable: true\n            });\n            /* eslint-enable */\n        }\n\n        if (instance.init) {\n            instance.init.apply(instance, arguments);\n        }\n\n        return instance;\n    }\n});\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ObservableArray);\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export createComputedProp */\n/* unused harmony export observableAssign */\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = makeObservable;\n/* unused harmony export watchProp */\n/* unused harmony export watchPropOnce */\n/* unused harmony export unwatchProp */\n/* unused harmony export notifyPropWatchers */\n/* unused harmony export observableMixin */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_dataStore__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_dataStore___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_dataStore__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_micro_libs_src_jsutils_EventEmitter__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_micro_libs_src_jsutils_EventEmitter___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_common_micro_libs_src_jsutils_EventEmitter__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common__ = __webpack_require__(3);\n/* unused harmony reexport setDependencyTracker */\n/* unused harmony reexport unsetDependencyTracker */\n/* unused harmony reexport stopDependeeNotifications */\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n\n\n\n\n//=======================================================\nvar PRIVATE = __WEBPACK_IMPORTED_MODULE_2_common_micro_libs_src_jsutils_dataStore___default.a.create();\nvar OBJECT = Object;\n\n// aliases\nvar objectCreate = OBJECT.create;\nvar objectDefineProperty = OBJECT.defineProperty;\nvar objectHasOwnProperty = Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"g\" /* bindCallTo */])(__WEBPACK_IMPORTED_MODULE_5__common__[\"c\" /* OBJECT_PROTOTYPE */].hasOwnProperty);\n\nvar objectKeys = Object.keys;\nvar noopEventListener = objectCreate({\n    off: function off() {}\n});\n\n/**\r\n * Adds the ability to observe `Object` property values for changes.\r\n * Uses an internal `EventEmitter` instance to list and trigger events,\r\n * and `Object.defineProperty` getter/setters to setup watchers on\r\n * property values.\r\n *\r\n * Currently has no support for addition or deletion from the object,\r\n * but with the ES7 forth coming Proxy functionality, that will be\r\n * added.\r\n *\r\n * @class ObservableObject\r\n * @extends Compose\r\n *\r\n * @param {Object} [model]\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.watchAll=true]\r\n *  if `model` was given on input, then all properties will be automatically made watchable.\r\n * @param {Boolean} [options.deep=true]\r\n *  If set to true, the model is walked and all deep objects made observable as well\r\n *\r\n * @example\r\n *\r\n * // Used as a mixin\r\n * var myObj = {\r\n *      first: \"paul\",\r\n *      last: \"tavares\"\r\n * };\r\n *\r\n * ObservableObject.mixin(myObj);\r\n *\r\n * myObj.on(\"first\", function(newValue, oldValue){\r\n *      alert(\"first name was changed\");\r\n * });\r\n *\r\n * @example\r\n *\r\n * // Used as part of a class prototype\r\n * var MyModel = Compose.extend(ObservableObject);\r\n *\r\n * var user = MyModel.create({\r\n *      first: \"paul\",\r\n *      last: \"tavares\"\r\n * });\r\n *\r\n * user.on(\"first\", function(newValue, oldValue){\r\n *  alert(\"first name was change\")\r\n * });\r\n *\r\n */\nvar ObservableObject = __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose___default.a.extend( /** @lends ObservableObject.prototype */{\n    init: function init(model, options) {\n        var opt = __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend___default()({}, this.getFactory().defaults, options);\n\n        if (model) {\n            // FIXME: need to create prop that uses original getter/setters from `model` - or no?\n            __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend___default()(this, model);\n\n            if (opt.watchAll) {\n                makeObservable(this, null, opt.deep);\n            }\n\n            getInstance(this).opt = opt;\n        }\n    },\n\n\n    /**\r\n     * Add a callback to changes on a given property\r\n     *\r\n     * @param {String|Object} prop\r\n     *  Object property name. If wanting to list to all changes to the object, the\r\n     *  object instance itself can be passed as the prop.\r\n     *\r\n     * @param {Function} callback\r\n     *  A callback function to list to the event. The callback function\r\n     *  can cancel any queued event callbacks by returning `true` (boolean).\r\n     *\r\n     * @return {EventListener}\r\n     *\r\n     * @example\r\n     *\r\n     * obj.on(\"firstName\", () => {});\r\n     *\r\n     * // List to all changes\r\n     * obj.on(obj, () => {});\r\n     */\n    on: function on(prop, callback) {\n        return watchProp(this, prop, callback);\n    },\n\n    /**\r\n     * Remove a callback the listening queue of a for a given property name\r\n     *\r\n     * @param {String} prop\r\n     *  Object property name\r\n     *\r\n     * @param {Function} callback\r\n     *  The callback that should be removed.\r\n     */\n    off: function off(prop, callback) {\n        unwatchProp(this, prop, callback);\n    },\n\n    /**\r\n     * Add a callback for changes on a given property that is called only once\r\n     *\r\n     * @param {String} prop\r\n     *  Object property name\r\n     *\r\n     * @param {Function} callback\r\n     *  The callback that should be removed.\r\n     */\n    once: function once(prop, callback) {\n        return watchPropOnce(this, prop, callback);\n    },\n\n    /**\r\n     * Emit an event and execute any callback listening. Any of the listening\r\n     * events can cancel the calling of queued callbacks by returning `true`\r\n     * (boolean)\r\n     *\r\n     * @param {String} prop\r\n     */\n    emit: function emit(prop) {\n        return notifyPropWatchers(this, prop);\n    },\n\n    /**\r\n     * Copies the properties of one or more objects into the current observable\r\n     * and makes those properties \"watchable\".\r\n     *\r\n     * @param {...Object} args\r\n     *\r\n     * @returns {Object}\r\n     */\n    assign: function assign() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return observableAssign.apply(undefined, [this].concat(_toConsumableArray(args)));\n    },\n\n\n    /**\r\n     * Sets a property on the observable object and automatically makes it watchable\r\n     *\r\n     * @param {String} propName\r\n     * @param {*} [value]\r\n     * @returns {*}\r\n     */\n    setProp: function setProp(propName, value) {\n        makePropWatchable(this, propName);\n        return this[propName] = value;\n    }\n});\n\n/**\r\n * Returns the private Instance data for this object\r\n *\r\n * @private\r\n * @param {Object} observableObj\r\n *\r\n * @return {EventEmitter}\r\n */\nfunction getInstance(observableObj) {\n    if (!PRIVATE.has(observableObj)) {\n        var instData = __WEBPACK_IMPORTED_MODULE_3_common_micro_libs_src_jsutils_EventEmitter___default.a.create();\n        var watched = instData.watched = {};\n\n        instData.opt = __WEBPACK_IMPORTED_MODULE_1_common_micro_libs_src_jsutils_objectExtend___default()({}, ObservableObject.defaults);\n        var isQueued = false;\n        instData.notify = function () {\n            if (isQueued) {\n                return;\n            }\n            isQueued = true;\n            __WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick___default()(function () {\n                instData.emit(\"\");\n                isQueued = false;\n            });\n        };\n\n        PRIVATE.set(observableObj, instData);\n\n        if (observableObj.onDestroy) {\n            observableObj.onDestroy(function () {\n                objectKeys(watched).forEach(function (propName) {\n                    watched[propName].destroy();\n\n                    // FIXME remove property getter/setter on the object (if still there)\n\n                    delete watched[propName];\n                });\n\n                delete instData.watched;\n                PRIVATE.delete(observableObj);\n                instData.destroy();\n            }.bind(observableObj));\n        }\n    }\n    return PRIVATE.get(observableObj);\n}\n\n/**\r\n * A property setup\r\n *\r\n * @private\r\n * @class Observable~PropertySetup\r\n * @extends Compose\r\n */\nvar PropertySetup = __WEBPACK_IMPORTED_MODULE_0_common_micro_libs_src_jsutils_Compose___default.a.extend( /** @lends Observable~PropertySetup.prototype */{\n    init: function init(observable, propName) {\n        var _this = this;\n\n        var dependees = this.dependees = [];\n        this.propName = propName;\n        this._obj = observable;\n\n        var removeDependeeEvListener = Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"j\" /* onInternalEvent */])(__WEBPACK_IMPORTED_MODULE_5__common__[\"a\" /* EV_STOP_DEPENDEE_NOTIFICATION */], function (cb) {\n            var cbIndex = Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"e\" /* arrayIndexOf */])(dependees, cb);\n            if (cbIndex !== -1) {\n                Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"f\" /* arraySplice */])(dependees, cbIndex, 1);\n            }\n        });\n\n        this.onDestroy(function () {\n            Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"f\" /* arraySplice */])(_this.dependees, 0);\n            removeDependeeEvListener.off();\n            _this._obj = null;\n        });\n    },\n\n\n    propName: \"\",\n\n    /** @type Array */\n    dependees: null,\n\n    oldVal: null,\n\n    newVal: null,\n\n    queued: false,\n\n    isComputed: false,\n\n    /**\r\n     * Notifies everyone that is listening for events on this property\r\n     *\r\n     * @param [noDelay=false]\r\n     */\n    notify: function notify(noDelay) {\n        var _this2 = this;\n\n        var propSetup = this;\n\n        // Queue up calling all dependee notifiers\n        Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"d\" /* arrayForEach */])(this.dependees, function (cb) {\n            return Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"k\" /* queueDependeeNotifier */])(cb);\n        });\n\n        // If emitting of events for this property was already queued, exit\n        if (propSetup.queued) {\n            return;\n        }\n\n        propSetup.queued = true;\n\n        var notifyListeners = function notifyListeners() {\n            var propName = _this2.propName,\n                observable = _this2._obj;\n\n            propSetup.queued = false;\n            getInstance(observable).emit(propName, propSetup.newVal, propSetup.oldVal);\n            propSetup.oldVal = null;\n        };\n\n        if (noDelay) {\n            notifyListeners();\n            return;\n        }\n\n        __WEBPACK_IMPORTED_MODULE_4_common_micro_libs_src_jsutils_nextTick___default()(function () {\n            return notifyListeners();\n        });\n    }\n});\n\n/**\r\n * Checks to see if a given property on this object already has a watcher\r\n * and if not, it sets one up for it.\r\n *\r\n * @private\r\n * @param {ObservableObject} observable\r\n * @param {String} propName\r\n * @param {Function} [valueGetter]\r\n * @param {Function} [valueSetter]\r\n *\r\n * @return {EventEmitter}\r\n */\nfunction makePropWatchable(observable, propName, valueGetter, valueSetter) {\n    var inst = getInstance(observable);\n    var watched = inst.watched;\n\n    if (watched[propName]) {\n        return inst;\n    }\n\n    var currentValue = void 0;\n    var emitNotification = !(propName in observable);\n    var propDescriptor = Object.getOwnPropertyDescriptor(observable, propName);\n\n    if (propDescriptor) {\n        if (propDescriptor.configurable === false) {\n            // TODO: should we throw()?\n            return;\n        }\n\n        valueGetter = valueGetter || propDescriptor.get;\n        valueSetter = valueSetter || propDescriptor.set;\n\n        if (!valueGetter) {\n            currentValue = propDescriptor.value;\n        }\n    }\n\n    // if we're able to remove the current property (ex. Constants would fail),\n    // then change this attribute to be watched\n    if (delete observable[propName]) {\n        var propSetup = watched[propName] = PropertySetup.create(observable, propName);\n        var dependees = propSetup.dependees;\n\n        propSetup.oldVal = propSetup.newVal = currentValue;\n\n        objectDefineProperty(observable, propName, {\n            enumerable: true,\n            configurable: true,\n\n            // Getter will either delegate to the prior getter(),\n            // or return the value that was originally assigned to the property\n            get: function get() {\n                Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"n\" /* storeDependeeNotifiers */])(dependees);\n                return valueGetter ? valueGetter() : propSetup.newVal;\n            },\n\n            // Setter is how we detect changes to the value.\n            set: function set(newValue) {\n                if (propSetup.isComputed) {\n                    return; // TODO: should throw? or console.warn  ?\n                }\n\n                var oldValue = valueGetter ? valueGetter() : propSetup.newVal;\n\n                if (valueSetter) {\n                    newValue = valueSetter.call(observable, newValue);\n                } else {\n                    propSetup.oldVal = oldValue;\n                    propSetup.newVal = newValue;\n                }\n\n                // Dirty checking...\n                // Only trigger if values are different. Also, only add a trigger\n                // if one is not already queued.\n                if (newValue !== oldValue) {\n                    if (inst.opt.deep && newValue && Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"i\" /* isPureObject */])(newValue)) {\n                        makeObservable(newValue, null, true);\n                    }\n\n                    propSetup.notify();\n                }\n            }\n        });\n    } else {\n        console.log(new Error(\"Unable to watch property [\" + propName + \"] - delete failed\"));\n    }\n\n    if (emitNotification) {\n        inst.notify();\n    }\n\n    return inst;\n}\n\n/**\r\n * Created a computed property on a given object\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n * @param {Function} valueGenerator\r\n */\nfunction createComputedProp(observable, propName, valueGenerator) {\n    if (observable && propName && valueGenerator) {\n        var runValueGenerator = true;\n        var propValue = void 0;\n        var dependencyChangeNotifier = function dependencyChangeNotifier() {\n            // Trigger the Object property setter(). This does nothing as far as the\n            // computed value does, but provides compatibility for any code that\n            // might have overwritten the setter in order ot also listen for changes\n            // outside of this lib.\n            observable[propName] = \"\";\n\n            // Reset the internally cached prop value and set the flag to run the\n            // generator and then notify listeners.\n            propValue = null;\n            runValueGenerator = true;\n            getInstance(observable).watched[propName].notify();\n        };\n        var valueGetter = function valueGetter() {\n            // FIXME: should we detect circular loops?\n\n            if (!runValueGenerator) {\n                return propValue;\n            }\n\n            Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"l\" /* setDependencyTracker */])(dependencyChangeNotifier);\n\n            try {\n                propValue = valueGenerator.call(observable);\n            } catch (e) {\n                Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"o\" /* unsetDependencyTracker */])(dependencyChangeNotifier);\n                throw e;\n            }\n\n            Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"o\" /* unsetDependencyTracker */])(dependencyChangeNotifier);\n            runValueGenerator = false;\n            return propValue;\n        };\n        var valueSetter = function valueSetter() {\n            /* FIXME: should this anything? */\n            return propValue;\n        };\n\n        dependencyChangeNotifier[__WEBPACK_IMPORTED_MODULE_5__common__[\"b\" /* IS_COMPUTED_NOTIFIER */]] = true;\n\n        var inst = makePropWatchable(observable, propName, valueGetter, valueSetter);\n        inst.watched[propName].isComputed = true;\n\n        var isDestroyDone = false;\n        var destroy = function destroy() {\n            if (!isDestroyDone) {\n                isDestroyDone = true;\n                Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"m\" /* stopDependeeNotifications */])(dependencyChangeNotifier);\n                inst.watched[propName].destroy();\n                delete inst.watched[propName];\n                delete observable[propName];\n                observable[propName] = propValue;\n            }\n        };\n        return Object.create({ destroy: destroy });\n    }\n}\n\n/**\r\n * Assign the properties of one (or more) objects to the observable and\r\n * makes those properties \"watchable\"\r\n *\r\n * @param {Object} observable\r\n * @param {...Object} objs\r\n *\r\n * @return {Object} observable\r\n */\nfunction observableAssign(observable) {\n    for (var _len2 = arguments.length, objs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        objs[_key2 - 1] = arguments[_key2];\n    }\n\n    if (objs.length) {\n        Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"d\" /* arrayForEach */])(objs, function (obj) {\n            Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"d\" /* arrayForEach */])(objectKeys(obj), function (key) {\n                makePropWatchable(observable, key);\n                observable[key] = obj[key];\n            });\n        });\n    }\n    return observable;\n}\n\n/**\r\n * Makes an Object observable or a given property of the object observable.\r\n *\r\n * @param {Object} observable\r\n *  The object that should be made observable.\r\n *\r\n * @param {String} [propName]\r\n *  if left unset, then all existing `own properties` of the object will\r\n *  be made observable.\r\n *\r\n * @param {Boolean} [deep=false]\r\n *  If set to `true` then the object, or the value the given `prop` (if defined)\r\n *  will be \"walked\" and any object found made an observable as well.\r\n *\r\n * @param {Function} [onEach]\r\n *  A callback function to be called as each property is \"walked\". The property value\r\n *  is provided on input to the callback\r\n */\nfunction makeObservable(observable, propName, deep, onEach) {\n    if (observable) {\n        if (propName) {\n            makePropWatchable(observable, propName);\n        } else {\n            Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"d\" /* arrayForEach */])(objectKeys(observable), function (prop) {\n                return makePropWatchable(observable, prop);\n            });\n        }\n\n        if (deep) {\n            Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"d\" /* arrayForEach */])(objectKeys(observable), function (key) {\n                if (observable[key] && Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"i\" /* isPureObject */])(observable[key])) {\n                    makeObservable(observable[key], null, deep);\n                }\n\n                if (onEach) {\n                    onEach(observable[key]);\n                }\n            });\n        }\n    }\n}\n\n/**\r\n * Watch a given object property for changes.\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n *  The `observable` property name or, if wanting to list to all property changes,\r\n *  the actual `observable` instance\r\n * @param {Function} notifier\r\n *\r\n * @returns {EventEmitter#EventListener}\r\n */\nfunction watchProp(observable, propName, notifier) {\n    var inst = getInstance(observable);\n\n    if (propName === observable) {\n        return inst.on(inst, notifier);\n    } else if (objectHasOwnProperty(observable, propName)) {\n        makePropWatchable(observable, propName);\n        return inst.on(propName, notifier);\n    } else {\n        return noopEventListener;\n    }\n}\n\n/**\r\n * Watch for changes on a given object property only once\r\n * (automatically stops listening after the first invocation).\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n * @param {Function} notifier\r\n * @returns {EventEmitter#EventListener}\r\n */\nfunction watchPropOnce(observable, propName, notifier) {\n    var inst = getInstance(observable);\n\n    if (propName === observable) {\n        return inst.once(inst, notifier);\n    } else if (objectHasOwnProperty(observable, propName)) {\n        makePropWatchable(observable, propName);\n        return inst.once(propName, notifier);\n    } else {\n        return noopEventListener;\n    }\n}\n\n/**\r\n * Stop watching an object property.\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n * @param {Function} notifier\r\n */\nfunction unwatchProp(observable, propName, notifier) {\n    return getInstance(observable).off(propName, notifier);\n}\n\n/**\r\n * Notifies watchers of a given Observable property\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n */\nfunction notifyPropWatchers(observable, propName) {\n    var watched = getInstance(observable).watched;\n    if (watched[propName]) {\n        watched[propName].notify(true);\n    }\n}\n\n/**\r\n * Adds ObservableObject capabilities to an object.\r\n *\r\n * @method ObservableObject.mixin\r\n *\r\n * @param {Object} observable\r\n *\r\n * @return {Object}\r\n *  Same object that was given on input will be returned\r\n */\nfunction observableMixin(observable) {\n    if (observable) {\n        Object(__WEBPACK_IMPORTED_MODULE_5__common__[\"d\" /* arrayForEach */])(objectKeys(ObservableObject.prototype), function (method) {\n            if (!(method in observable) || observable[method] !== ObservableObject.prototype[method]) {\n                objectDefineProperty(observable, method, {\n                    value: ObservableObject.prototype[method],\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        });\n    }\n    return observable;\n}\n\nObservableObject.createComputed = createComputedProp;\nObservableObject.mixin = observableMixin;\n\n/**\r\n * Default options to the ObservableObject constructor\r\n *\r\n * @type Object\r\n * @name ObservableObject.defaults\r\n */\nObservableObject.defaults = {\n    watchAll: true,\n    deep: true\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ObservableObject);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// ObservableData.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8c23057a113b6700add4","// POLYFILL FOR WEAKMAP\r\n//  [pt] changed how \"delete\" is defined so that it can work in IE8\r\n\r\n/* jshint ignore:start */\r\n/**\r\n * @license\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\nif (typeof WeakMap === 'undefined') {\r\n  (function() {\r\n    var defineProperty = Object.defineProperty;\r\n    var counter = Date.now() % 1e9;\r\n\r\n    var WeakMap = function() {\r\n      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\r\n    };\r\n\r\n    WeakMap.prototype = {\r\n      set: function(key, value) {\r\n        var entry = key[this.name];\r\n        if (entry && entry[0] === key)\r\n          entry[1] = value;\r\n        else\r\n          defineProperty(key, this.name, {value: [key, value], writable: true});\r\n        return this;\r\n      },\r\n      get: function(key) {\r\n        var entry;\r\n        return (entry = key[this.name]) && entry[0] === key ?\r\n            entry[1] : undefined;\r\n      },\r\n      // [pt] Quotes around the delete property needed for IE8\r\n      \"delete\": function(key) {\r\n        var entry = key[this.name];\r\n        if (!entry || entry[0] !== key) return false;\r\n        entry[0] = entry[1] = undefined;\r\n        return true;\r\n      },\r\n      has: function(key) {\r\n        var entry = key[this.name];\r\n        if (!entry) return false;\r\n        return entry[0] === key;\r\n      }\r\n    };\r\n\r\n    window.WeakMap = WeakMap;\r\n  })();\r\n}\r\n/* jshint ignore:end */\r\n\r\n/**\r\n * Returns an object that contains an initialized WeakMap (`stash` property)\r\n * where data can be stored.\r\n *\r\n * @namespace dataStore\r\n *\r\n */\r\nvar dataStore = /** @lends dataStore */{\r\n    /**\r\n     * Stash data here.\r\n     * @type WeakMap\r\n     */\r\n    stash:  new WeakMap(),\r\n    /**\r\n     * Create a private data store and return it.\r\n     * @return {WeakMap}\r\n     */\r\n    create: function(){\r\n        return new WeakMap();\r\n    }\r\n};\r\n\r\nexport default dataStore;\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/common-micro-libs/src/jsutils/dataStore.js","import Compose   from \"./Compose\"\r\nimport dataStore from \"./dataStore\"\r\n\r\n//----------------------------------------------------------------\r\nconst PRIVATE           = dataStore.create();\r\nconst arraySlice        = Function.call.bind(Array.prototype.slice);\r\nconst isFunction        = function(fn){return typeof fn === \"function\";};\r\nconst objectCreate      = Object.create;\r\nconst objectKeys        = Object.keys;\r\n\r\n/**\r\n * Emits events. Use it to extend other modules and thus add events to them.\r\n *\r\n * @class EventEmitter\r\n * @extends Compose\r\n */\r\nconst EventEmitter = Compose.extend(/** @lends EventEmitter.prototype */{\r\n    /**\r\n     * Add a callback to a given event name\r\n     *\r\n     * @param {String} evName\r\n     *  The event name to be listened to or a list of event sperated by a space.\r\n     *  The EventEmitter instance can be used as the `evName` as well which will\r\n     *  essentially listen to all events.\r\n     *  Note that this special event however, will change the arguments\r\n     *  passed to the callback by pre-pending the Event Name (`String`) and\r\n     *  appending the Component instance.\r\n     *\r\n     * @param {Function} callback\r\n     *  A callback function to listen to the event. The callback function\r\n     *  can cancel any queued event callbacks by returning `true` (boolean).\r\n     *\r\n     * @return {EventEmitter#EventListener}\r\n     *\r\n     * @example\r\n     *\r\n     * events.on(\"some-event\", (...args) => {});\r\n     *\r\n     * // List to all events\r\n     * events.on(events, (evNameTriggered, ...args) => {}\r\n     */\r\n    on: function(evName, callback){\r\n        let { all, listeners }  = getSetup.call(this);\r\n        let events              = getEventNameList(evName).reduce((eventList, eventName) => {\r\n            let callbackIndex;\r\n            let off;\r\n\r\n            // If eventName is `this` then listen to all events\r\n            if (eventName === this) {\r\n                all.push(callback);\r\n                callbackIndex = all.length - 1;\r\n                off = () => all[callbackIndex] = null;\r\n            }\r\n            else {\r\n                if (!(eventName in listeners)) {\r\n                    listeners[eventName] = [];\r\n                }\r\n\r\n                listeners[eventName].push(callback);\r\n                callbackIndex = listeners[eventName].length - 1;\r\n                off = () => listeners[eventName][callbackIndex] = null;\r\n            }\r\n\r\n            eventList[eventName] = objectCreate({ off });\r\n            return eventList;\r\n        }, {});\r\n        /**\r\n         * EventEmitter Listener object, returned when one of the listener setter methods\r\n         * (ex. `on()`, `once()`, `pipe`) are used.\r\n         *\r\n         * @typedef {Object} EventEmitter~EventListener\r\n         *\r\n         * @property {Object} listeners\r\n         *  An object with the individual listeners. Each respective event listener\r\n         *  has an `off()` method to turn that listener off.\r\n         *\r\n         * @property {Function} off\r\n         *  Remove callback from event.\r\n         */\r\n        let response = objectCreate({\r\n            off: function(){\r\n                objectKeys(events).forEach(eventName => events[eventName].off());\r\n            }\r\n        });\r\n\r\n        response.listeners = events;\r\n        return response;\r\n    },\r\n\r\n    /**\r\n     * Remove a callback from a given event\r\n     *\r\n     * @param {String} evName\r\n     * @param {Function} callback\r\n     *\r\n     */\r\n    off: function(evName, callback){\r\n        const {all, listeners} = getSetup.call(this);\r\n        const removeCallbackIterator = function(thisCallback, index){\r\n            if (thisCallback === callback) {\r\n                listeners[evName][index] = null;\r\n                return true;\r\n            }\r\n        };\r\n\r\n        if (evName === this) {\r\n            all.some(removeCallbackIterator);\r\n            return;\r\n        }\r\n\r\n        if (evName in listeners) {\r\n            listeners[evName].some(removeCallbackIterator);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Add a callback to a given event name that is executed only once.\r\n     *\r\n     * @param {String} evName\r\n     *  The event name. This can be a list of event delimited with a space. Each\r\n     *  event listeners will be triggered at most once.\r\n     * @param {Function} callback\r\n     *\r\n     * @return {EventEmitter#EventListener}\r\n     */\r\n    once: function(evName, callback){\r\n        let events = getEventNameList(evName).reduce((eventListeners, eventName) => {\r\n            let eventNameListener = this.on(evName, function(...args){\r\n                eventNameListener.off();\r\n                callback(...args);\r\n            });\r\n\r\n            eventListeners[eventName] = eventNameListener;\r\n            return eventListeners;\r\n        }, {});\r\n\r\n        let response = objectCreate({\r\n            off: function(){\r\n                objectKeys(events).forEach(eventName => events[eventName].off());\r\n            }\r\n        });\r\n\r\n        response.listeners = events;\r\n        return response;\r\n    },\r\n\r\n    /**\r\n     * Emit an event and execute any callback listening. Any of the listening\r\n     * events can cancel the calling of queued callbacks by returning `true`\r\n     * (boolean)\r\n     *\r\n     * @param {String} evName\r\n     *  The event name to be triggered. __NOTE__: can not be a `\"*\"` or the EventEmitter\r\n     *  instance since they holds special meaning.\r\n     *\r\n     * @param {...Function} callbackArgs\r\n     */\r\n    emit: function(evName){\r\n        if (evName === \"*\" || evName === this) {\r\n            try { console.warning(\"EventEmitter#emit(): can not emit to events to '*'\"); } catch(e){} // jshint ignore:line\r\n            return;\r\n        }\r\n\r\n        var\r\n        setup           = getSetup.call(this),\r\n        eventListeners  = setup.listeners,\r\n        eventPipes      = setup.pipes,\r\n        eventAll        = setup.all,\r\n        args            = arraySlice(arguments, 1),\r\n        isCanceled      = false,\r\n        callbackHandler = function(callback){\r\n            if (isFunction(callback)) {\r\n                var response = callback.apply(callback, args);\r\n\r\n                // if a boolean true was returned, don't call any more\r\n                // listeners.\r\n                if (response && typeof response === \"boolean\") {\r\n                    isCanceled = true;\r\n                    return true;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (evName in eventListeners) {\r\n            // Regular event listeners\r\n            (eventListeners[evName] || []).some(callbackHandler);\r\n        }\r\n\r\n        // Event listeners for all events\r\n        if (\r\n            !isCanceled &&\r\n            (\r\n                \"*\" in eventListeners ||\r\n                eventAll.length\r\n            )\r\n        ) {\r\n            // Special event \"*\": pass event name and instance\r\n            args = arraySlice(arguments, 0);\r\n            args.push(this);\r\n\r\n            (eventListeners[\"*\"] || []).concat(eventAll).some(callbackHandler);\r\n\r\n            // set args back to original\r\n            args = arraySlice(arguments, 1);\r\n        }\r\n\r\n        eventPipes.forEach(function(pipe){\r\n            if (isFunction(pipe)) {\r\n                pipe(evName, args);\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Emit the events from one instance of EventEmitter to another. Useful\r\n     * for when multiple components are used together as part of a larger\r\n     * component and have the need to emit events to a common EventEmitter.\r\n     *\r\n     * @param {EventEmitter} pipeTo\r\n     *  The EventEmitter instance object to where events should be piped.\r\n     *\r\n     * @param {String} [prefix]\r\n     *  If defined, prefix will be added to any event emited. Example:\r\n     *  if defining `foo-` as the prefix, then every event emitted will\r\n     *  prefixed wth this value. So a `click` event on the source will\r\n     *  be piped as `foo-click`.\r\n     *\r\n     * @param {Boolean} [includeInstance=true]\r\n     *  When set to `true` (default), the piped event will include the source\r\n     *  instance as an additional argument to the event that is piped.\r\n     *\r\n     *  @return {EventListener}\r\n     */\r\n    pipe: function(pipeTo, prefix, includeInstance){\r\n        if (!pipeTo || !pipeTo.on) {\r\n            return objectCreate({ off: function(){} });\r\n        }\r\n        var pipes = getSetup.call(this).pipes,\r\n            callbackIndex;\r\n\r\n        pipes.push(function(triggeredEvName, args){\r\n            if (prefix) {\r\n                args.unshift(prefix + triggeredEvName);\r\n\r\n            } else {\r\n                args.unshift(triggeredEvName);\r\n            }\r\n\r\n            if (includeInstance || typeof includeInstance === \"undefined\") {\r\n                args.push(this);\r\n            }\r\n\r\n            pipeTo.emit.apply(pipeTo, args);\r\n        }.bind(this));\r\n\r\n        callbackIndex = pipes.length - 1;\r\n\r\n        return objectCreate({\r\n            off: function(){\r\n                pipes[callbackIndex] = null;\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Returns a boolean indicating if the current EventEmitter has listener\r\n     * @returns {Boolean}\r\n     */\r\n    hasListeners() {\r\n        const { listeners, pipes } = getSetup.call(this);\r\n        return objectKeys(listeners).some(evName => listeners[evName].some(evListener => !!evListener)) ||\r\n                pipes.some(evEmitter => !!evEmitter);\r\n    }\r\n});\r\n\r\n/**\r\n * Returns the instance setup object. Creates it if it does not have one.\r\n * @private\r\n * @this EventEmitter\r\n */\r\nfunction getSetup(){\r\n    if (!PRIVATE.has(this)) {\r\n        /*\r\n            listeners: {\r\n                'evName': [ Callbacks ]\r\n            },\r\n            pipes: [ Callbacks ]\r\n            all: [ Callbacks ]\r\n        */\r\n        PRIVATE.set(this, {\r\n            listeners:  {},\r\n            pipes:      [],\r\n            all:        []\r\n        });\r\n\r\n        // When this object is destroyed, remove all data\r\n        if (this.onDestroy) {\r\n            this.onDestroy(function(){\r\n                if (PRIVATE.has(this)) {\r\n                    PRIVATE['delete'](this); // using ['delete'] because of IE\r\n                }\r\n            }.bind(this));\r\n        }\r\n    }\r\n    return PRIVATE.get(this);\r\n}\r\n\r\nfunction getEventNameList(eventNamesStr) {\r\n    if (\"string\" === typeof eventNamesStr) {\r\n        return eventNamesStr.split(/\\s+/);\r\n    }\r\n    return [eventNamesStr];\r\n}\r\n\r\n/**\r\n * Adds event emitter functionality to an object\r\n *\r\n * @param {Object} target\r\n */\r\nEventEmitter.mixin = function (target) {\r\n    if (target) {\r\n        [\"on\", \"off\", \"emit\", \"once\", \"pipe\"].forEach(method => {\r\n            Object.defineProperty(target, method, {\r\n                configurable: true,\r\n                value: EventEmitter.prototype[method].bind(target)\r\n            });\r\n        });\r\n    }\r\n};\r\n\r\nexport default EventEmitter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/common-micro-libs/src/jsutils/EventEmitter.js","let reIsNativeCode = /native code/i;\r\n\r\n/**\r\n * Executes a function at the end of the current event Loop - during micro-task processing\r\n *\r\n * @param {Function} callback\r\n */\r\nlet nextTick = (function(){\r\n    if (typeof setImediate !== \"undefined\" && reIsNativeCode.test(setImediate.toString())) {\r\n        return setImediate;\r\n    }\r\n\r\n    // Native Promsie? Use it.\r\n    if (typeof Promise === 'function' && reIsNativeCode.test(Promise.toString())) {\r\n        let resolved = Promise.resolve();\r\n        return function _nextTick(fn) {\r\n            resolved.then(fn).catch(e => console.log(e));\r\n        };\r\n    }\r\n\r\n    // fallback to setTimeout\r\n    // From: https://bugzilla.mozilla.org/show_bug.cgi?id=686201#c68\r\n    let immediates = [];\r\n    let processing = false;\r\n\r\n    function processPending() {\r\n        setTimeout(function() {\r\n            immediates.shift()();\r\n            if (immediates.length) {\r\n                processPending();\r\n\r\n            } else {\r\n                processing = false;\r\n            }\r\n        }, 0);\r\n    }\r\n\r\n    return function _nextTick(fn) {\r\n        immediates.push(fn);\r\n        if (!processing) {\r\n            processing = true;\r\n            processPending();\r\n        }\r\n    };\r\n})();\r\n\r\nexport default nextTick;\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/common-micro-libs/src/jsutils/nextTick.js","import EventEmitter     from \"common-micro-libs/src/jsutils/EventEmitter\"\r\nimport nextTick         from \"common-micro-libs/src/jsutils/nextTick\"\r\n\r\n//=======================================================================\r\n\r\nexport const INTERNAL_EVENTS                = EventEmitter.create();\r\nexport const EV_STOP_DEPENDEE_NOTIFICATION  = \"1\";\r\nexport const ARRAY_PROTOTYPE                = Array.prototype;\r\nexport const IS_COMPUTED_NOTIFIER           = \"__od_cn__\";\r\nexport const OBJECT_PROTOTYPE               = Object.prototype;\r\n\r\nexport const bindCallTo         = Function.call.bind.bind(Function.call);\r\nexport const dependeeList       = [];\r\nexport const onInternalEvent    = INTERNAL_EVENTS.on.bind(INTERNAL_EVENTS);\r\nexport const emitInternalEvent  = INTERNAL_EVENTS.emit.bind(INTERNAL_EVENTS);\r\nexport const isArray            = Array.isArray;\r\nexport const arrayIndexOf       = bindCallTo(ARRAY_PROTOTYPE.indexOf);\r\nexport const arraySplice        = bindCallTo(ARRAY_PROTOTYPE.splice);\r\nexport const arrayForEach       = bindCallTo(ARRAY_PROTOTYPE.forEach);\r\nexport const isPureObject       = o => o && OBJECT_PROTOTYPE.toString.call(o) === \"[object Object]\";\r\n\r\n/**\r\n * Allows for adding a Dependee notifier to the global list of dependency trackers.\r\n *\r\n * @param {Function} dependeeNotifier\r\n */\r\nexport function setDependencyTracker(dependeeNotifier) {\r\n    if (dependeeNotifier && arrayIndexOf(dependeeList, dependeeNotifier) === -1) {\r\n        dependeeList.push(dependeeNotifier);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a Dependee notifier from the global list of dependency trackers.\r\n *\r\n * @param {Function} dependeeNotifier\r\n */\r\nexport function unsetDependencyTracker(dependeeNotifier) {\r\n    if (!dependeeNotifier) {\r\n        return;\r\n    }\r\n    const index = arrayIndexOf(dependeeList, dependeeNotifier);\r\n    if (index !== -1) {\r\n        arraySplice(dependeeList, index, 1);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a Dependee notifier from any stored ObservableProperty list of dependees, thus\r\n * stopping all notifications to that depenedee.\r\n *\r\n * @param {Function} dependeeNotifier\r\n */\r\nexport function stopDependeeNotifications(dependeeNotifier) {\r\n    if (dependeeNotifier) {\r\n        emitInternalEvent(EV_STOP_DEPENDEE_NOTIFICATION, dependeeNotifier);\r\n    }\r\n}\r\n\r\n\r\nexport const queueDependeeNotifier = (() => {\r\n    const dependeeNotifiers = [];\r\n    const execNotifiers     = () => arrayForEach(arraySplice(dependeeNotifiers, 0), notifierCb => notifierCb());\r\n\r\n    return notifierCb => {\r\n        if (!notifierCb || arrayIndexOf(dependeeNotifiers, notifierCb) !== -1) {\r\n            return;\r\n        }\r\n\r\n        // Computed property notifiers are lightweight, so execute\r\n        // these now and don't queue them.\r\n        if (notifierCb[IS_COMPUTED_NOTIFIER]) {\r\n            notifierCb();\r\n            return;\r\n        }\r\n\r\n        const callNextTick = !dependeeNotifiers.length;\r\n        dependeeNotifiers.push(notifierCb);\r\n\r\n        if (callNextTick) {\r\n            nextTick(execNotifiers);\r\n        }\r\n    };\r\n})();\r\n\r\n\r\nexport function storeDependeeNotifiers (store) {\r\n    if (store && dependeeList.length) {\r\n        arrayForEach(dependeeList, dependeeCallback => {\r\n            if (arrayIndexOf(store, dependeeCallback) === -1) {\r\n                store.push(dependeeCallback);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/common.js","import objectExtend from \"./objectExtend\"\r\nimport dataStore    from \"./dataStore\"\r\n\r\n//=========================================================\r\nconst PRIVATE = dataStore.create();\r\n\r\n// Aliases\r\nconst objectCreate = Object.create;\r\n\r\n\r\n// return all KEYs of an object, even those that are not iterable\r\nfunction objectKeys(prototype){\r\n    let k, keys = [];\r\n    for (k in prototype){\r\n        keys.push(k);\r\n    }\r\n    return keys;\r\n}\r\n\r\n// Base instance methods for Compose'd object\r\nconst baseMethods = /** @lends Compose.prototype */{\r\n\r\n    /**\r\n     * Property indicating whether instance has been destroyed\r\n     */\r\n    isDestroyed: false,\r\n\r\n    /**\r\n     * instance initializing code\r\n     */\r\n    init: function(){},\r\n\r\n    /**\r\n     * Destroys the instance, by removing its private data.\r\n     */\r\n    destroy:    function(){\r\n        if (PRIVATE.has(this)) {\r\n            PRIVATE.get(this).forEach(function(callback, i){\r\n                if (\"function\" === typeof callback) {\r\n                    callback();\r\n                }\r\n            });\r\n\r\n            PRIVATE.delete(this);\r\n        }\r\n\r\n        if (\"boolean\" === typeof this.isDestroyed) {\r\n            this.isDestroyed = true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to the queue to be called when this object's `.destroy()`\r\n     * is called.\r\n     *\r\n     * @param {Function} callback\r\n     */\r\n    onDestroy: function(callback){\r\n        getInstanceState(this).push(callback);\r\n    },\r\n\r\n    /**\r\n     * Returns the factory for this instance.\r\n     *\r\n     * @return {Compose}\r\n     */\r\n    getFactory: function(){} // set by .extend()\r\n};\r\n\r\n\r\nconst staticMethods = /** @lends Compose */{\r\n\r\n    /**\r\n     * Creates an new factory based on the prototye of the current Factory\r\n     * and any other Factory given on input.\r\n     *\r\n     * @return {Compose}\r\n     */\r\n    extend: function(...args){\r\n        let Factory = function(){};\r\n\r\n        Factory.prototype = args.reduce(function(newProto, obj){\r\n            if (obj) {\r\n                const thisObjProto = (obj.prototype || obj);\r\n                objectKeys(thisObjProto).forEach(function(objKey){\r\n                    newProto[objKey] = thisObjProto[objKey];\r\n                });\r\n            }\r\n            return newProto;\r\n        }, objectCreate(this.prototype));\r\n\r\n        // Add a method to the Factory prototype that allows retrieval of\r\n        // factory static properties.\r\n        Factory.prototype.getFactory = function(){\r\n            return Factory;\r\n        };\r\n\r\n        // Extend new factory with statics from this factory\r\n        return objectExtend(true, Factory, this);\r\n    },\r\n\r\n    /**\r\n     * Checks if the Object given on input looks like an instance of this Factory.\r\n     *\r\n     * @return {Boolean}\r\n     */\r\n    isInstanceOf: function(instanceObj){\r\n\r\n        if (!instanceObj) {\r\n            return false;\r\n        }\r\n\r\n        var neededKeys = objectKeys(this.prototype);\r\n\r\n        // If any prototype key is not in the object prototype, then return false\r\n        return !neededKeys.some(function(protoKey){\r\n            return typeof instanceObj[protoKey] === \"undefined\";\r\n        });\r\n\r\n    },\r\n\r\n    /**\r\n     * Creates an instance object based on this factory.\r\n     *\r\n     * @return {Object}\r\n     */\r\n    create: function(){\r\n        var instance = objectCreate(this.prototype);\r\n        if (instance.init) {\r\n            instance.init.apply(instance, arguments);\r\n        }\r\n        return instance;\r\n    },\r\n\r\n    /**\r\n     * Returns a standard callback that can be used to remove cleanup instance state\r\n     * from specific Store (WeakMap). Returned function will destroy known Instances\r\n     * that have destroy methods.\r\n     *\r\n     * @param {Object} instanceState\r\n     * @param {WeakMap} [stateStore]\r\n     *\r\n     * @return {Function}\r\n     *\r\n     * @example\r\n     *\r\n     * const MY_PRIVATE = new WeakMap();\r\n     * cont NewWdg = Componse.extend({\r\n     *      init() {\r\n     *          const state = {};\r\n     *          MY_PRIVATE.set(this, state);\r\n     *          ...\r\n     *\r\n     *          this.onDestroy(Compose.getDestroyCallback(state, MY_PRIVATE));\r\n     *      }\r\n     * });\r\n     */\r\n    getDestroyCallback(instanceState, stateStore) {\r\n        return () => {\r\n            if (instanceState) {\r\n                // Destroy all Compose object\r\n                Object.keys(instanceState).forEach(function (prop) {\r\n                    if (instanceState[prop]) {\r\n                        [\r\n                            \"destroy\",      // Compose\r\n                            \"remove\",       // DOM Events Listeners\r\n                            \"off\"           // EventEmitter Listeners\r\n                        ].some((method) => {\r\n                            if (instanceState[prop][method]) {\r\n                                instanceState[prop][method]();\r\n                                return true;\r\n                            }\r\n                        });\r\n\r\n                        instanceState[prop] = undefined;\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (stateStore && stateStore.has && stateStore.has(instanceState)) {\r\n                stateStore['delete'](instanceState);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nfunction getInstanceState(inst) {\r\n    if (!PRIVATE.has(inst)) {\r\n        PRIVATE.set(inst, []);\r\n    }\r\n\r\n    return PRIVATE.get(inst);\r\n}\r\n\r\n/**\r\n * Composes new factory methods from a list of given Objects/Classes.\r\n *\r\n * @class Compose\r\n *\r\n * @example\r\n *\r\n * var Widget = Compose.create(Model, Events);\r\n *\r\n * myWidget = Widget.create();\r\n *\r\n */\r\nvar Compose = function(){};\r\nCompose.prototype = objectCreate(baseMethods);\r\nobjectExtend(Compose, staticMethods);\r\n\r\nexport default Compose;\r\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/common-micro-libs/src/jsutils/Compose.js","const OBJECT_TYPE   = \"[object Object]\";\r\nconst _toString     = Function.call.bind(Object.prototype.toString);\r\n\r\n//============================================================\r\n\r\n/**\r\n * Extends an object with the properties of another.\r\n *\r\n * @param {Object|Boolean} mergeIntoObj\r\n *  The object that will have the properties of every other object provided\r\n *  on input merged into. This can also be a `Boolean`, in which case,\r\n *  a deep merge of objects will be done - argument number 2 will\r\n *  become the `mergeIntoObj`.\r\n * @param {...Object} mergeObjects\r\n *\r\n * @return {Object}\r\n */\r\nexport default function objectExtend(mergeIntoObj, ...mergeObjects) {\r\n    let response    = mergeIntoObj || {};\r\n    let total       = mergeObjects.length;\r\n    let deepMerge   = false;\r\n    let i;\r\n    let key;\r\n\r\n    if (typeof mergeIntoObj === \"boolean\") {\r\n        deepMerge   = mergeIntoObj;\r\n        response    = mergeObjects.shift() || {};\r\n        total       = mergeObjects.length;\r\n    }\r\n\r\n    for (i = 0; i < total; i++) {\r\n        if (!mergeObjects[i]) {\r\n            continue;\r\n        }\r\n\r\n        for (key in mergeObjects[i]) {\r\n            if (mergeObjects[i].hasOwnProperty(key)){\r\n                if (\r\n                    deepMerge &&\r\n                    _toString(response[key]) === OBJECT_TYPE &&\r\n                    _toString(mergeObjects[i][key]) === OBJECT_TYPE\r\n                ) {\r\n                    response[key] = objectExtend( true, response[key], mergeObjects[i][key]);\r\n                    \r\n                } else {\r\n                    response[key] = mergeObjects[i][key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return response;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./node_modules/common-micro-libs/src/jsutils/objectExtend.js","import ObservableArray, { mixin }           from \"./ObservableArray\"\r\nimport ObservableObject, { makeObservable } from \"./ObservableObject\"\r\nimport {\r\n    isPureObject,\r\n    arrayForEach,\r\n    isArray }  from \"./common\"\r\n\r\n//==================================================================\r\n\r\n/**\r\n * Observes all data - object and arrays - given on input.\r\n *\r\n * @param {...Object|...Array} data\r\n */\r\nexport function observeAll(...data) {\r\n    arrayForEach(data, dataItem => {\r\n        if (isPureObject(dataItem)) {\r\n            makeObservable(dataItem, null, true, propValue => {\r\n                if (propValue && isArray(propValue)) {\r\n                    observeAll(propValue);\r\n                }\r\n            });\r\n        }\r\n        else if (isArray(dataItem)) {\r\n            mixin(dataItem);\r\n            observeAll(...dataItem);\r\n        }\r\n    });\r\n}\r\n\r\nexport { ObservableArray, ObservableObject };\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import EventEmitter from \"common-micro-libs/src/jsutils/EventEmitter\"\r\nimport dataStore    from \"common-micro-libs/src/jsutils/dataStore\"\r\nimport nextTick     from \"common-micro-libs/src/jsutils/nextTick\"\r\n\r\nimport {\r\n    EV_STOP_DEPENDEE_NOTIFICATION,\r\n    onInternalEvent,\r\n    storeDependeeNotifiers,\r\n    setDependencyTracker,\r\n    unsetDependencyTracker,\r\n    stopDependeeNotifications,\r\n    queueDependeeNotifier,\r\n    isArray,\r\n    arrayForEach,\r\n    arraySplice,\r\n    arrayIndexOf\r\n} from \"./common\"\r\n\r\n//==============================================================\r\nconst PRIVATE           = dataStore.create();\r\nconst OBSERVABLE_FLAG   = \"___observable_array___\";\r\nconst ArrayPrototype    = Array.prototype;\r\nconst objectDefineProp  = Object.defineProperty;\r\nconst noop              = () => {};\r\nconst isObservable      = arr => arr[OBSERVABLE_FLAG] === noop;\r\nconst changeMethods     = [\r\n    'pop',\r\n    'push',\r\n    'shift',\r\n    'splice',\r\n    'unshift',\r\n    'sort',\r\n    'reverse'\r\n];\r\n\r\n/**\r\n * An Array like object with the added ability to listen to events.\r\n * It supports all methods available to a normal array, like `forEach`,\r\n * `some` and `reduce`\r\n *\r\n * @class ObservableArray\r\n *\r\n * @extends EventEmitter\r\n * @extends Array\r\n *\r\n * @fires ObservableArray#change\r\n */\r\nlet ObservableArray = EventEmitter.extend(/** @lends ObservableArray.prototype */{\r\n\r\n    /**\r\n     * The length of the array. Unlike the `length` property, this one is able\r\n     * to notify dependees if any are set to be track dependencies.\r\n     *\r\n     * @name len\r\n     * @type {Number}\r\n     */\r\n\r\n    // For backwards compatible with initial version\r\n    // use `len` property instead\r\n    size: function(){\r\n        storeDependeeNotifiers(getInstance(this).dependees);\r\n        return this.length;\r\n    },\r\n\r\n    /**\r\n     * Returns a member of the collection given an index (zero based),\r\n     * or updates the item at a given index with a new value.\r\n     *\r\n     * @param {Number} index\r\n     * @param {*} [newValue]\r\n     */\r\n    item: function (index){\r\n        let args    = ArrayPrototype.slice.call(arguments, 0);\r\n        let _array  = this;\r\n\r\n        storeDependeeNotifiers(getInstance(this).dependees);\r\n\r\n        // GET mode..\r\n        if (args.length === 1) {\r\n            return _array[index];\r\n        }\r\n\r\n        // Update mode... Emits event\r\n        let updateResponse = _array[index] = args[1];\r\n        notifyDependees(_array);\r\n\r\n        return updateResponse;\r\n    }\r\n});\r\n\r\nfunction getInstance (obArray) {\r\n    if (!PRIVATE.has(obArray)) {\r\n        const dependees = [];\r\n        let isQueued = false;\r\n        const inst = {\r\n            dependees: dependees,\r\n\r\n            notify() {\r\n                // Queue up calling all dependee notifiers\r\n                arrayForEach(dependees, cb => queueDependeeNotifier(cb));\r\n\r\n                if (isQueued) {\r\n                    return;\r\n                }\r\n\r\n                /**\r\n                 * ObservableArray was changed. Event will provide the value returned\r\n                 * by the Array method that made the change.\r\n                 *\r\n                 * @event ObservableArray#change\r\n                 * @type {*}\r\n                 */\r\n                nextTick(() => {\r\n                    EventEmitter.prototype.emit.call(obArray, \"change\");\r\n                    isQueued = false;\r\n                });\r\n            }\r\n        };\r\n\r\n        PRIVATE.set(obArray, inst);\r\n\r\n        const ev1 = onInternalEvent(EV_STOP_DEPENDEE_NOTIFICATION, cb => {\r\n            const cbIndex = arrayIndexOf(dependees, cb);\r\n            if (cbIndex !== -1) {\r\n                arraySplice(dependees, cbIndex, 1);\r\n            }\r\n        });\r\n\r\n        if (obArray.onDestroy) {\r\n            obArray.onDestroy(() => {\r\n                dependees.splice(0);\r\n                ev1.off();\r\n                PRIVATE.delete(obArray);\r\n            });\r\n        }\r\n    }\r\n    return PRIVATE.get(obArray);\r\n}\r\n\r\n/**\r\n * Converts an array instance methods to a wrapped version that can detect changes\r\n * and also track dependee notifiers when data is accessed from the array\r\n *\r\n * @param {Array} arr\r\n *\r\n * @return {Array}\r\n */\r\nfunction makeArrayObservable (arr) {\r\n    // If it looks like this array is already an being observered, then exit.\r\n    if (isObservable(arr)) {\r\n        return;\r\n    }\r\n\r\n    objectDefineProp(arr, OBSERVABLE_FLAG, { get: () => noop });\r\n\r\n    // Create new Array instance prototype\r\n    const newArrProto = Object.create(arr.__proto__); // eslint-disable-line\r\n\r\n    // Add all methods of Array.prototype to the collection\r\n    Object.getOwnPropertyNames(ArrayPrototype).forEach(function(method){\r\n        if (method === \"constructor\" || typeof ArrayPrototype[method] !== \"function\") {\r\n            return;\r\n        }\r\n\r\n        const origMethod    = newArrProto[method].bind(arr);\r\n        const doEvents      = changeMethods.indexOf(method) !== -1;\r\n\r\n        objectDefineProp(newArrProto, method, {\r\n            value: function observable(...args){\r\n                storeDependeeNotifiers(getInstance(this).dependees);\r\n\r\n                let response = origMethod(...args);\r\n\r\n                // If the response is an array and its not this instance, then\r\n                // ensure it is an instance of this ObservableArray\r\n                if (isArray(response) && response !== this && this.getFactory) {\r\n                    response = this.getFactory().create(response);\r\n                }\r\n\r\n                // If Array method can manipulate the array, then emit event\r\n                if (doEvents) {\r\n                    notifyDependees(this);\r\n                }\r\n\r\n                return response;\r\n            },\r\n            writable:       true,\r\n            configurable:   true\r\n        });\r\n    });\r\n\r\n    // Add `len` property, which is shorthand for `length` but with added\r\n    // ability to observe for array changes when called and trigger notifiers\r\n    // when changed.\r\n    objectDefineProp(newArrProto, \"len\", {\r\n        get() {\r\n            storeDependeeNotifiers(getInstance(this).dependees);\r\n            return this.length;\r\n        },\r\n\r\n        set(n) {\r\n            const response = this.length = n;\r\n            notifyDependees(this);\r\n            return response;\r\n        },\r\n\r\n        configurable: true\r\n    });\r\n\r\n    arr.__proto__ = newArrProto; // eslint-disable-line\r\n\r\n    return arr;\r\n}\r\n\r\nfunction notifyDependees(arrObj) {\r\n    getInstance(arrObj).notify();\r\n}\r\n\r\n/**\r\n * Make an array instance observable in place\r\n *\r\n * @param {Array} arr\r\n *\r\n * @return {Array}\r\n */\r\nexport function mixin(arr) {\r\n    if (!isArray(arr)) {\r\n        arr = [];\r\n    }\r\n\r\n    return ObservableArray.create(arr);\r\n}\r\n\r\n// Define the \"create\" factory method that will then redefine each\r\n// our proxyied methods of Array prototype into the array instance\r\nobjectDefineProp(ObservableArray, \"create\", {\r\n    value: function(arrayInstance){\r\n        let instance        = arrayInstance || [];\r\n        let thisPrototype   = this.prototype;\r\n\r\n        if (isObservable(instance)) {\r\n            return instance;\r\n        }\r\n\r\n        makeArrayObservable(instance);\r\n\r\n        // Copy all methods in this prototype to the Array instance\r\n        for (let prop in thisPrototype){\r\n            /* eslint-disable */\r\n            objectDefineProp(instance, prop, {\r\n                value:          thisPrototype[prop],\r\n                writable:       true,\r\n                configurable:   true\r\n            });\r\n            /* eslint-enable */\r\n        }\r\n\r\n        if (instance.init) {\r\n            instance.init.apply(instance, arguments);\r\n        }\r\n\r\n        return instance;\r\n    }\r\n});\r\n\r\nexport default ObservableArray;\r\n\r\nexport {\r\n    setDependencyTracker,\r\n    unsetDependencyTracker,\r\n    stopDependeeNotifications\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ObservableArray.js","import Compose          from \"common-micro-libs/src/jsutils/Compose\"\r\nimport objectExtend     from \"common-micro-libs/src/jsutils/objectExtend\"\r\nimport dataStore        from \"common-micro-libs/src/jsutils/dataStore\"\r\nimport EventEmitter     from \"common-micro-libs/src/jsutils/EventEmitter\"\r\nimport nextTick         from \"common-micro-libs/src/jsutils/nextTick\"\r\n\r\nimport {\r\n    EV_STOP_DEPENDEE_NOTIFICATION,\r\n    IS_COMPUTED_NOTIFIER,\r\n    OBJECT_PROTOTYPE,\r\n    setDependencyTracker,\r\n    unsetDependencyTracker,\r\n    stopDependeeNotifications,\r\n    storeDependeeNotifiers,\r\n    queueDependeeNotifier,\r\n    bindCallTo,\r\n    arrayIndexOf,\r\n    arraySplice,\r\n    arrayForEach,\r\n    onInternalEvent,\r\n    isPureObject\r\n} from \"./common\"\r\n\r\n//=======================================================\r\nconst PRIVATE               = dataStore.create();\r\nconst OBJECT                = Object;\r\n\r\n\r\n// aliases\r\nconst objectCreate          = OBJECT.create;\r\nconst objectDefineProperty  = OBJECT.defineProperty;\r\nconst objectHasOwnProperty  = bindCallTo(OBJECT_PROTOTYPE.hasOwnProperty);\r\n\r\nconst objectKeys            = Object.keys;\r\nconst noopEventListener     = objectCreate({ off() {} });\r\n\r\n/**\r\n * Adds the ability to observe `Object` property values for changes.\r\n * Uses an internal `EventEmitter` instance to list and trigger events,\r\n * and `Object.defineProperty` getter/setters to setup watchers on\r\n * property values.\r\n *\r\n * Currently has no support for addition or deletion from the object,\r\n * but with the ES7 forth coming Proxy functionality, that will be\r\n * added.\r\n *\r\n * @class ObservableObject\r\n * @extends Compose\r\n *\r\n * @param {Object} [model]\r\n * @param {Object} [options]\r\n * @param {Boolean} [options.watchAll=true]\r\n *  if `model` was given on input, then all properties will be automatically made watchable.\r\n * @param {Boolean} [options.deep=true]\r\n *  If set to true, the model is walked and all deep objects made observable as well\r\n *\r\n * @example\r\n *\r\n * // Used as a mixin\r\n * var myObj = {\r\n *      first: \"paul\",\r\n *      last: \"tavares\"\r\n * };\r\n *\r\n * ObservableObject.mixin(myObj);\r\n *\r\n * myObj.on(\"first\", function(newValue, oldValue){\r\n *      alert(\"first name was changed\");\r\n * });\r\n *\r\n * @example\r\n *\r\n * // Used as part of a class prototype\r\n * var MyModel = Compose.extend(ObservableObject);\r\n *\r\n * var user = MyModel.create({\r\n *      first: \"paul\",\r\n *      last: \"tavares\"\r\n * });\r\n *\r\n * user.on(\"first\", function(newValue, oldValue){\r\n *  alert(\"first name was change\")\r\n * });\r\n *\r\n */\r\nconst ObservableObject = Compose.extend(/** @lends ObservableObject.prototype */{\r\n    init(model, options) {\r\n        const opt = objectExtend({}, this.getFactory().defaults, options);\r\n\r\n        if (model) {\r\n            // FIXME: need to create prop that uses original getter/setters from `model` - or no?\r\n            objectExtend(this, model);\r\n\r\n            if (opt.watchAll) {\r\n                makeObservable(this, null, opt.deep);\r\n            }\r\n\r\n            getInstance(this).opt = opt;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Add a callback to changes on a given property\r\n     *\r\n     * @param {String|Object} prop\r\n     *  Object property name. If wanting to list to all changes to the object, the\r\n     *  object instance itself can be passed as the prop.\r\n     *\r\n     * @param {Function} callback\r\n     *  A callback function to list to the event. The callback function\r\n     *  can cancel any queued event callbacks by returning `true` (boolean).\r\n     *\r\n     * @return {EventListener}\r\n     *\r\n     * @example\r\n     *\r\n     * obj.on(\"firstName\", () => {});\r\n     *\r\n     * // List to all changes\r\n     * obj.on(obj, () => {});\r\n     */\r\n    on: function(prop, callback){\r\n        return watchProp(this, prop, callback);\r\n    },\r\n\r\n    /**\r\n     * Remove a callback the listening queue of a for a given property name\r\n     *\r\n     * @param {String} prop\r\n     *  Object property name\r\n     *\r\n     * @param {Function} callback\r\n     *  The callback that should be removed.\r\n     */\r\n    off: function(prop, callback){\r\n        unwatchProp(this, prop, callback);\r\n    },\r\n\r\n    /**\r\n     * Add a callback for changes on a given property that is called only once\r\n     *\r\n     * @param {String} prop\r\n     *  Object property name\r\n     *\r\n     * @param {Function} callback\r\n     *  The callback that should be removed.\r\n     */\r\n    once: function(prop, callback){\r\n        return watchPropOnce(this, prop, callback);\r\n    },\r\n\r\n    /**\r\n     * Emit an event and execute any callback listening. Any of the listening\r\n     * events can cancel the calling of queued callbacks by returning `true`\r\n     * (boolean)\r\n     *\r\n     * @param {String} prop\r\n     */\r\n    emit: function(prop){\r\n        return notifyPropWatchers(this, prop);\r\n    },\r\n\r\n    /**\r\n     * Copies the properties of one or more objects into the current observable\r\n     * and makes those properties \"watchable\".\r\n     *\r\n     * @param {...Object} args\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    assign(...args) {\r\n        return observableAssign(this, ...args);\r\n    },\r\n\r\n    /**\r\n     * Sets a property on the observable object and automatically makes it watchable\r\n     *\r\n     * @param {String} propName\r\n     * @param {*} [value]\r\n     * @returns {*}\r\n     */\r\n    setProp(propName, value) {\r\n        makePropWatchable(this, propName);\r\n        return this[propName] = value;\r\n    }\r\n});\r\n\r\n/**\r\n * Returns the private Instance data for this object\r\n *\r\n * @private\r\n * @param {Object} observableObj\r\n *\r\n * @return {EventEmitter}\r\n */\r\nfunction getInstance(observableObj){\r\n    if (!PRIVATE.has(observableObj)) {\r\n        const instData = EventEmitter.create();\r\n        const watched = instData.watched = {};\r\n\r\n        instData.opt = objectExtend({}, ObservableObject.defaults);\r\n        let isQueued = false;\r\n        instData.notify = () => {\r\n            if (isQueued) {\r\n                return;\r\n            }\r\n            isQueued = true;\r\n            nextTick(() => {\r\n                instData.emit(\"\");\r\n                isQueued = false;\r\n            });\r\n        };\r\n\r\n        PRIVATE.set(observableObj, instData);\r\n\r\n        if (observableObj.onDestroy) {\r\n            observableObj.onDestroy(function(){\r\n                objectKeys(watched).forEach(propName => {\r\n                    watched[propName].destroy();\r\n\r\n                    // FIXME remove property getter/setter on the object (if still there)\r\n\r\n                    delete watched[propName];\r\n                });\r\n\r\n                delete instData.watched;\r\n                PRIVATE.delete(observableObj);\r\n                instData.destroy();\r\n            }.bind(observableObj));\r\n        }\r\n    }\r\n    return PRIVATE.get(observableObj);\r\n}\r\n\r\n/**\r\n * A property setup\r\n *\r\n * @private\r\n * @class Observable~PropertySetup\r\n * @extends Compose\r\n */\r\nconst PropertySetup = Compose.extend(/** @lends Observable~PropertySetup.prototype */{\r\n    init(observable, propName) {\r\n        const dependees = this.dependees = [];\r\n        this.propName = propName;\r\n        this._obj = observable;\r\n\r\n        const removeDependeeEvListener = onInternalEvent(EV_STOP_DEPENDEE_NOTIFICATION, cb => {\r\n            const cbIndex = arrayIndexOf(dependees, cb);\r\n            if (cbIndex !== -1) {\r\n                arraySplice(dependees, cbIndex, 1);\r\n            }\r\n        });\r\n\r\n        this.onDestroy(() => {\r\n            arraySplice(this.dependees, 0);\r\n            removeDependeeEvListener.off();\r\n            this._obj = null;\r\n        })\r\n    },\r\n\r\n    propName: \"\",\r\n\r\n    /** @type Array */\r\n    dependees: null,\r\n\r\n    oldVal: null,\r\n\r\n    newVal: null,\r\n\r\n    queued: false,\r\n\r\n    isComputed: false,\r\n\r\n    /**\r\n     * Notifies everyone that is listening for events on this property\r\n     *\r\n     * @param [noDelay=false]\r\n     */\r\n    notify(noDelay){\r\n        const propSetup = this;\r\n\r\n        // Queue up calling all dependee notifiers\r\n        arrayForEach(this.dependees, cb => queueDependeeNotifier(cb));\r\n\r\n        // If emitting of events for this property was already queued, exit\r\n        if (propSetup.queued) {\r\n            return;\r\n        }\r\n\r\n        propSetup.queued = true;\r\n\r\n        const notifyListeners = () => {\r\n            const {propName, _obj:observable} = this;\r\n            propSetup.queued = false;\r\n            getInstance(observable).emit(propName, propSetup.newVal, propSetup.oldVal);\r\n            propSetup.oldVal = null;\r\n        };\r\n\r\n        if (noDelay) {\r\n            notifyListeners();\r\n            return;\r\n        }\r\n\r\n        nextTick(() => notifyListeners());\r\n    }\r\n});\r\n\r\n/**\r\n * Checks to see if a given property on this object already has a watcher\r\n * and if not, it sets one up for it.\r\n *\r\n * @private\r\n * @param {ObservableObject} observable\r\n * @param {String} propName\r\n * @param {Function} [valueGetter]\r\n * @param {Function} [valueSetter]\r\n *\r\n * @return {EventEmitter}\r\n */\r\nfunction makePropWatchable(observable, propName, valueGetter, valueSetter){\r\n    let inst    = getInstance(observable);\r\n    let watched = inst.watched;\r\n\r\n    if (watched[propName]){\r\n        return inst;\r\n    }\r\n\r\n    let currentValue;\r\n    const emitNotification  = !(propName in observable);\r\n    const propDescriptor    = Object.getOwnPropertyDescriptor(observable, propName);\r\n\r\n    if (propDescriptor) {\r\n        if (propDescriptor.configurable === false) {\r\n            // TODO: should we throw()?\r\n            return;\r\n        }\r\n\r\n        valueGetter = valueGetter || propDescriptor.get;\r\n        valueSetter = valueSetter || propDescriptor.set;\r\n\r\n        if (!valueGetter) {\r\n            currentValue = propDescriptor.value;\r\n        }\r\n    }\r\n\r\n    // if we're able to remove the current property (ex. Constants would fail),\r\n    // then change this attribute to be watched\r\n    if (delete observable[propName]) {\r\n        const propSetup = watched[propName] = PropertySetup.create(observable, propName);\r\n        const dependees = propSetup.dependees;\r\n\r\n        propSetup.oldVal = propSetup.newVal = currentValue;\r\n\r\n        objectDefineProperty(observable, propName, {\r\n            enumerable:     true,\r\n            configurable:   true,\r\n\r\n            // Getter will either delegate to the prior getter(),\r\n            // or return the value that was originally assigned to the property\r\n            get: function(){\r\n                storeDependeeNotifiers(dependees);\r\n                return valueGetter ? valueGetter() : propSetup.newVal;\r\n            },\r\n\r\n            // Setter is how we detect changes to the value.\r\n            set: function(newValue){\r\n                if (propSetup.isComputed) {\r\n                    return; // TODO: should throw? or console.warn  ?\r\n                }\r\n\r\n                let oldValue = valueGetter ? valueGetter() : propSetup.newVal;\r\n\r\n                if (valueSetter) {\r\n                    newValue = valueSetter.call(observable, newValue);\r\n\r\n                } else {\r\n                    propSetup.oldVal = oldValue;\r\n                    propSetup.newVal = newValue;\r\n                }\r\n\r\n                // Dirty checking...\r\n                // Only trigger if values are different. Also, only add a trigger\r\n                // if one is not already queued.\r\n                if (newValue !== oldValue) {\r\n                    if (inst.opt.deep && newValue && isPureObject(newValue)) {\r\n                        makeObservable(newValue, null, true);\r\n                    }\r\n\r\n                    propSetup.notify();\r\n                }\r\n            }\r\n        });\r\n\r\n    } else {\r\n        console.log(new Error(\"Unable to watch property [\" + propName + \"] - delete failed\"));\r\n    }\r\n\r\n    if (emitNotification) {\r\n        inst.notify();\r\n    }\r\n\r\n    return inst;\r\n}\r\n\r\n/**\r\n * Created a computed property on a given object\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n * @param {Function} valueGenerator\r\n */\r\nexport function createComputedProp(observable, propName, valueGenerator) {\r\n    if (observable && propName && valueGenerator) {\r\n        let runValueGenerator = true;\r\n        let propValue;\r\n        const dependencyChangeNotifier = () => {\r\n            // Trigger the Object property setter(). This does nothing as far as the\r\n            // computed value does, but provides compatibility for any code that\r\n            // might have overwritten the setter in order ot also listen for changes\r\n            // outside of this lib.\r\n            observable[propName] = \"\";\r\n\r\n            // Reset the internally cached prop value and set the flag to run the\r\n            // generator and then notify listeners.\r\n            propValue = null;\r\n            runValueGenerator = true;\r\n            getInstance(observable).watched[propName].notify();\r\n\r\n        };\r\n        const valueGetter = () => {\r\n            // FIXME: should we detect circular loops?\r\n\r\n            if (!runValueGenerator) {\r\n                return propValue;\r\n            }\r\n\r\n            setDependencyTracker(dependencyChangeNotifier);\r\n\r\n            try {\r\n                propValue = valueGenerator.call(observable);\r\n            }\r\n            catch(e) {\r\n                unsetDependencyTracker(dependencyChangeNotifier);\r\n                throw e;\r\n            }\r\n\r\n            unsetDependencyTracker(dependencyChangeNotifier);\r\n            runValueGenerator = false;\r\n            return propValue;\r\n        };\r\n        const valueSetter = () => {\r\n            /* FIXME: should this anything? */\r\n            return propValue;\r\n        };\r\n\r\n        dependencyChangeNotifier[IS_COMPUTED_NOTIFIER] = true;\r\n\r\n        const inst = makePropWatchable(observable, propName, valueGetter, valueSetter);\r\n        inst.watched[propName].isComputed = true;\r\n\r\n        let isDestroyDone = false;\r\n        const destroy = () => {\r\n            if (!isDestroyDone) {\r\n                isDestroyDone = true;\r\n                stopDependeeNotifications(dependencyChangeNotifier);\r\n                inst.watched[propName].destroy();\r\n                delete inst.watched[propName];\r\n                delete observable[propName];\r\n                observable[propName] = propValue;\r\n            }\r\n        };\r\n        return Object.create({ destroy });\r\n    }\r\n}\r\n\r\n/**\r\n * Assign the properties of one (or more) objects to the observable and\r\n * makes those properties \"watchable\"\r\n *\r\n * @param {Object} observable\r\n * @param {...Object} objs\r\n *\r\n * @return {Object} observable\r\n */\r\nexport function observableAssign(observable, ...objs) {\r\n    if (objs.length) {\r\n        arrayForEach(objs, obj => {\r\n            arrayForEach(objectKeys(obj), key => {\r\n                makePropWatchable(observable, key);\r\n                observable[key] = obj[key];\r\n            });\r\n        });\r\n    }\r\n    return observable;\r\n}\r\n\r\n/**\r\n * Makes an Object observable or a given property of the object observable.\r\n *\r\n * @param {Object} observable\r\n *  The object that should be made observable.\r\n *\r\n * @param {String} [propName]\r\n *  if left unset, then all existing `own properties` of the object will\r\n *  be made observable.\r\n *\r\n * @param {Boolean} [deep=false]\r\n *  If set to `true` then the object, or the value the given `prop` (if defined)\r\n *  will be \"walked\" and any object found made an observable as well.\r\n *\r\n * @param {Function} [onEach]\r\n *  A callback function to be called as each property is \"walked\". The property value\r\n *  is provided on input to the callback\r\n */\r\nexport function makeObservable(observable, propName, deep, onEach) {\r\n    if (observable) {\r\n        if (propName) {\r\n            makePropWatchable(observable, propName);\r\n        }\r\n        else {\r\n            arrayForEach(objectKeys(observable), prop => makePropWatchable(observable, prop));\r\n        }\r\n\r\n        if (deep) {\r\n            arrayForEach(objectKeys(observable), key => {\r\n                if (observable[key] && isPureObject(observable[key])) {\r\n                    makeObservable(observable[key], null, deep);\r\n                }\r\n\r\n                if (onEach) {\r\n                    onEach(observable[key]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Watch a given object property for changes.\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n *  The `observable` property name or, if wanting to list to all property changes,\r\n *  the actual `observable` instance\r\n * @param {Function} notifier\r\n *\r\n * @returns {EventEmitter#EventListener}\r\n */\r\nexport function watchProp(observable, propName, notifier) {\r\n    const inst = getInstance(observable);\r\n\r\n    if (propName === observable) {\r\n        return inst.on(inst, notifier);\r\n    }\r\n    else if (objectHasOwnProperty(observable, propName)){\r\n        makePropWatchable(observable, propName);\r\n        return inst.on(propName, notifier);\r\n    }\r\n    else {\r\n        return noopEventListener;\r\n    }\r\n}\r\n\r\n/**\r\n * Watch for changes on a given object property only once\r\n * (automatically stops listening after the first invocation).\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n * @param {Function} notifier\r\n * @returns {EventEmitter#EventListener}\r\n */\r\nexport function watchPropOnce(observable, propName, notifier) {\r\n    const inst = getInstance(observable);\r\n\r\n    if (propName === observable) {\r\n        return inst.once(inst, notifier);\r\n    }\r\n    else if (objectHasOwnProperty(observable, propName)){\r\n        makePropWatchable(observable, propName);\r\n        return inst.once(propName, notifier);\r\n    }\r\n    else {\r\n        return noopEventListener;\r\n    }\r\n}\r\n\r\n/**\r\n * Stop watching an object property.\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n * @param {Function} notifier\r\n */\r\nexport function unwatchProp(observable, propName, notifier) {\r\n    return getInstance(observable).off(propName, notifier);\r\n}\r\n\r\n\r\n/**\r\n * Notifies watchers of a given Observable property\r\n *\r\n * @param {Object} observable\r\n * @param {String} propName\r\n */\r\nexport function notifyPropWatchers(observable, propName) {\r\n    let watched = getInstance(observable).watched;\r\n    if (watched[propName]) {\r\n        watched[propName].notify(true);\r\n    }\r\n}\r\n\r\n/**\r\n * Adds ObservableObject capabilities to an object.\r\n *\r\n * @method ObservableObject.mixin\r\n *\r\n * @param {Object} observable\r\n *\r\n * @return {Object}\r\n *  Same object that was given on input will be returned\r\n */\r\nexport function observableMixin(observable) {\r\n    if (observable) {\r\n        arrayForEach(objectKeys(ObservableObject.prototype), function(method){\r\n            if (!(method in observable) || observable[method] !== ObservableObject.prototype[method]) {\r\n                objectDefineProperty(observable, method, {\r\n                    value:          ObservableObject.prototype[method],\r\n                    enumerable:     false,\r\n                    configurable:   true\r\n                });\r\n            }\r\n        });\r\n    }\r\n    return observable;\r\n}\r\n\r\nObservableObject.createComputed = createComputedProp;\r\nObservableObject.mixin = observableMixin;\r\n\r\n/**\r\n * Default options to the ObservableObject constructor\r\n *\r\n * @type Object\r\n * @name ObservableObject.defaults\r\n */\r\nObservableObject.defaults = {\r\n    watchAll:   true,\r\n    deep:       true\r\n};\r\n\r\nexport default ObservableObject;\r\nexport {\r\n    setDependencyTracker,\r\n    unsetDependencyTracker,\r\n    stopDependeeNotifications\r\n};\n\n\n// WEBPACK FOOTER //\n// ./src/ObservableObject.js"],"sourceRoot":""}